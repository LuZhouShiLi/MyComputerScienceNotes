# 309. 最佳买卖股票时机含冷冻期

## 题目
给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

## 思路

* 定义dp数组  初始化dp数组  四种状态 0 1 2 3
* 状态一：买入股票状态（今天买入股票 或者是之前就买入股票）
* 状态二：卖出股票状态  但是度过了冷冻期 仍然保持卖出股票状态
* 状态三：今天卖出股票
* 状态四：冷冻期
* 保持买入股票的状态  或者 刚刚度过冷冻期  或者 已经度过冷冻期 dp[i][0] = max(dp[i - 1][0],max(dp[i - 1][3] - prices[i],dp[i - 1][1] - prices[i]));

* 前一天也是卖出股票的状态  或者前一天是冷冻期,dp[i][1] = max(dp[i - 1][1],dp[i - 1][3]);


* 前一天是买入股票状态 dp[i][2] = dp[i - 1][0] + prices[i];

* 前一天刚刚卖出股票 dp[i][3] = dp[i - 1][2];


## 代码

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0)
        {
            return 0;
        }

        // 定义dp数组  初始化dp数组  四种状态 0 1 2 3
        // 状态一：买入股票状态（今天买入股票 或者是之前就买入股票）
        // 状态二：卖出股票状态  但是度过了冷冻期 仍然保持卖出股票状态
        // 状态三：今天卖出股票
        // 状态四：冷冻期

        vector<vector<int>> dp(n,vector<int>(4,0));
        

        //dp数组初始化
        dp[0][0] = -prices[0];// 买入股票状态
        dp[0][1] = 0;// 卖出股票 度过冷冻期
        dp[0][2] = 0;// 今天卖出股票
        dp[0][3] = 0;// 冷冻期

        for(int i = 1; i < n; i++)
        {
            // 状态转移方程

            // 保持买入股票的状态  或者 刚刚度过冷冻期  或者 已经度过冷冻期
            dp[i][0] = max(dp[i - 1][0],max(dp[i - 1][3] - prices[i],dp[i - 1][1] - prices[i]));

            // 前一天也是卖出股票的状态  或者前一天是冷冻期
            dp[i][1] = max(dp[i - 1][1],dp[i - 1][3]);


            // 前一天是买入股票状态
            dp[i][2] = dp[i - 1][0] + prices[i];

            // 前一天刚刚卖出股票
            dp[i][3] = dp[i - 1][2];
        }

        // 最后一定是卖出股票状态 取最大
        return max(dp[n - 1][3],max(dp[n - 1][1],dp[n - 1][2]));

    }
};

```
