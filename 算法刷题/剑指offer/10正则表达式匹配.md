# 题目-10.正则表达式匹配
&emsp;请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。

# 思路
&emsp; 如果字符中的第一个字符和模式中的第一个字符相匹配，那么在字符串和模式上都向后移动一个字符，然后匹配剩余的字符串和模式。如果字符串中的第一个字符和模式中的第一个字符不相匹配。则直接返回false。

&emsp;当模式中的第二个字符是'*'时，有两种匹配方式，一种选择是在模式上向后移动两个字符。（相当于'*'和它前面的字符都被忽略了，因为'*'可以匹配字符串中的0个字符）。如果模式中的第一个字符和字符串中的第一个字符相匹配，则在字符串上向后移动一个字符，而在模式上有两种选择：可以在模式上向后移动两个字符，也可以保持模式不变。



# 代码

```cpp
bool isMatch(char* s, char* p){
    // 两者都为空 true
    if(*s == '\0' && *p == '\0')
    {
        return true;
    }

    // str 不为空，patten为空
    if(*s != '\0' && *p == '\0')
    {
        return false;
    }
    // 匹配当前字符  查看下一个字符
    // 当下一个字符不是*时
    if(*(p + 1) != '*')
    {
        // 当前字符相同  或者str是任意字符  并且pattern中是.可以代表任意字符
        if(*s == *p || (*s != '\0' && *p == '.'))
        {
            return isMatch(s + 1,p + 1);// 匹配下一个字符
        }
        else
        {
            return false;
        }
    }
    else{
        if(*s == *p || (*s != '\0' && *p == '.'))
        {
            // 将pattern向后面移动两位 
            // 或者字符串向后移动一位
            return isMatch(s,p + 2) || isMatch(s + 1,p);
        }
        else
        {
            // 如果当前字符不匹配 直接将pattern后移两位
            // 也就是考察s与P + 2之后的字符串是否匹配
            return isMatch(s,p + 2);
        }
    }
}
```

