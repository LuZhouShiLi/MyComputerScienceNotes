# 二进制中1的个数

## 题目
![图 2](../../images/e1aa3c73e26730cfc4a635d8836854258f31da7f8101234930fdccfa884cefdc.png)  

## 左移或者右移运算符
&emsp;左移运算符表示将m左移N位。在左移n位的时候，最左边的N位将被丢弃，同时在最右边进行补0操作。

&emsp;右移运算符表示将M右移N位，在右移n位的时候，最右边的N位将被丢弃，但是右移是处理最左边的情形要复杂一点，如果是一个无符号数字，那么只需要用0补齐最左边的N位即可，但是如果是有符号数，负数右移之后，最左边补上1。

## 引起死循环的解法-未考虑负数情况

&emsp;对于正数情况，先判断整数二进制中最右边的那一位是不是1，接着把输入的整数右移一位，此时原来处于从右边数起的第二位就被移动到最右边了，在判断是不是1；这样每次移动一位，直到整个整数变成0为止。如何查看最右边的整数是不是1，只需要将该整数和1进行位与运算（1除了最后一位是1，其余位全部都是0），那么如果结果是1，就表示最后一位是1，否则是0。

```cpp
int NumberOf1(int n)
{
    int count = 0;
    while(n != 0)
    {
        if((n & 1) == 1)
        {
            count++;
        }
        n>> 1;// 右移一位
    }

    return count;
}
```

Question:将整数右移一位换成整数除以2可否？答案是否定的，除法的运算效率远远低于移位运算，在实际编程中，使用移位运算代替除法运算。

&emsp;但是上述问题中，输入的整数是一个有符号数：负数，那么右移只会让1的个数变多。陷入死循环。


## 常规解法-左移flag

&emsp;为了避免死循环，我们不右移输入的数字n，首先将N和1进行与运算，这就可以判断n的最低位是不是1，接着把1左移一位得到2（最右边的位补上0），再和N做与运算，这就可以判断n的次低位是不是1，反复左移，这样每次就可以判断N的其中一位是不是1。

```cpp
int NumberOf1(int n)
{
    int count = 0;
    unsigned int flag = 1;// 
    while(flag)
    {
        if(n & flag)
        {
            count++;
        }
        flag = flag << 1;// 左移一位
    }
    return count;
}

```

## 更优解

&emsp;将一个整数减去1，在和原来的整数做与运算就会把该整数最右边的1变成0，那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。（详细分析见剑指offer）

```cpp
int NumberOf1(int n)
{
    int count  = 0;
    while(n)
    {
        n = (n - 1) & n;
        count++;
    }
    return count;
}

```





