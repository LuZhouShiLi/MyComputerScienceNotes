# 简简单单学习Cpp-构造函数和析构函数

## 简单举例

* 当对象产生，必须初始化成员变量  对象销毁必须清理对象
* 初始化使用构造函数 清理使用析构函数，这两个函数是编译器调用


```cpp
# define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include "test.h"
using namespace std;

class Maker {
public:
	//构造函数的作用是初始化成员变量  是编译器去调用的
	Maker() {
		a = 10;
		cout << "构造函数初始化" << endl;
	}

	// 析构函数在对象销毁前  编译器调用析构函数
	~Maker() {
		cout << "析构函数" << endl;
	}

private:
	int a;
};



int main() {
	// 封装
	Maker m;
	
	system("pause");
	return EXIT_SUCCESS;
}

```

## 析构函数的作用

**释放内存空间**


```cpp

class Maker2 {
public:
	//构造函数的作用是初始化成员变量  是编译器去调用的
	Maker2(const char *name,int age) {
		cout << "有参构造函数" << endl;
		// 先从堆区开辟空间
		pName = (char*)malloc(strlen(name) + 1);// 字符串 /0
		// 将name内容复制到pName
		strcpy(pName, name);
		mAge = age;
	}

	// 析构函数在对象销毁前  编译器调用析构函数
	~Maker2() {
		cout << "析构函数" << endl;
		// 释放堆区空间
		if (pName != NULL) {
			free(pName);
			pName = NULL;
		}
	}

private:
	char* pName;
	int mAge;
};


```

## 构造函数进行重载

**构造函数可以重载，必须是public**

```cpp
class Maker3 {
public:
	Maker3() {
		// 无参构造函数
	}
	Maker3(int a) {
		// 有参构造函数   构造函数重载
	}
};

```

**有对象必然会调用构造函数，有对象销毁必然会调用析构函数，有多少个对象产生就会调用多少次构造函数**

## 小总结

* 构造函数和析构函数的权限必须是共有的
* 构造函数可以重载
* 构造函数没有返回值 不可以使用void 构造函数可以有参数 析构函数没有返回值 不可以使用void  没有参数



## 默认构造函数和析构函数

```cpp

class Maker3 {
public:
	// 默认的构造函数 不写也可以
	Maker3() {
		// 无参构造函数
	}
	
	// 默认的析构函数   不写也可以
	~Maker3() {

	}
};


```


## 拷贝构造

**用一个已经有的对象初始化另一个对象**

**其实编译器提供了默认的拷贝构造函数，就是对成员变量的简单拷贝**

```cpp

class Maker3 {
public:
	Maker3() {
		// 无参构造函数
		cout << "无参构造函数" << endl;
		a = 20;

	}

	// 拷贝构造函数
	Maker3(const Maker3& m) {
		cout << "拷贝构造函数" << endl;
		a = m.a;// 使用另一个对象 来初始化
	}
	
	// 默认的析构函数   不写也可以
	~Maker3() {

	}

private:
	int a;
};


void test01() {
	Maker3 m1;

	Maker3 m2(m1);

}

```

**注意：拷贝构造函数的形参必须使用引用**

* 编译器提供了那些默认函数
* 默认的构造函数
* 默认的析构函数
* 默认的拷贝构造函数
* 默认的赋值函数

