# 构造函数的调用规则

## 规则


* 如果提供了有参构造 那么编译器不会提供默认的构造函数
* 如果提供了拷贝构造函数 那么编译器不会提供默认的构造函数和默认的拷贝构造函数

```cpp
# define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include "test.h"
using namespace std;

class Maker {
public:
	//构造函数的作用是初始化成员变量  是编译器去调用的
	Maker() {
		cout << "无参构造函数" << endl;
	}

	Maker(int a) {
		cout << "有参构造函数" << endl;
	}

	Maker(const Maker& maker) {
		cout << "拷贝构造函数" << endl;
	}

	// 析构函数在对象销毁前  编译器调用析构函数
	~Maker() {
		cout << "析构函数" << endl;
	}

private:
	int a;
};

void test() {
	// Maker m;// error
	Maker m(10);
	Maker m2(m);// 调用默认的拷贝构造函数
}


int main() {
	// 封装
	Maker m;
	
	system("pause");
	return EXIT_SUCCESS;
}

```


## 多个对象的构造函数和析构函数

**首先调用成员对象的构造函数 然后调用自己的构造函数,析构函数的调用反过来**

```cpp
# define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include "test.h"
using namespace std;



class BMW {
public:
	BMW() {
		cout << "BMW构造" << endl;
	}

	~BMW() {
		cout << "BMW的析构函数" << endl;
	}
};


class Buick {
public:
	Buick() {
		cout << "Buick构造" << endl;
	}

	~Buick() {
		cout << "Buick的析构函数" << endl;
	}
};


class Maker {
public:
	//构造函数的作用是初始化成员变量  是编译器去调用的
	Maker() {
		cout << "无参构造函数" << endl;
	}

	Maker(int a) {
		cout << "有参构造函数" << endl;
	}

	Maker(const Maker& maker) {
		cout << "拷贝构造函数" << endl;
	}

	// 析构函数在对象销毁前  编译器调用析构函数
	~Maker() {
		cout << "析构函数" << endl;
	}

private:
	int a;
	BMW b;// 成员对象
	Buick bu;// 成员对象
};


void test() {
	Maker m;
}


int main() {
	// 封装
	test();
	
	system("pause");
	return EXIT_SUCCESS;
}

```


## 初始化列表

**初始化列表是调用成员对象的指定构造函数**
**如果使用初始化列表 那么所有的构造函数都要写初始化列表**

```cpp

# define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include "test.h"
using namespace std;



class BMW {
public:
	// 有参构造函数
	BMW(int a) {
		cout << "BMW构造" << endl;
	}

	~BMW() {
		cout << "BMW的析构函数" << endl;
	}
};


class Buick {
public:
	Buick() {
		cout << "Buick构造" << endl;
	}

	~Buick() {
		cout << "Buick的析构函数" << endl;
	}
};


class Maker {
public:
	//构造函数的作用是初始化成员变量  是编译器去调用的
	// 初始化参数列表
	Maker():b(10) {
		cout << "无参构造函数" << endl;
	}

	// 避免写死 直接吧形参进行赋值
	Maker(int a):b(a) {
		cout << "有参构造函数" << endl;
	}

	Maker(const Maker& maker) :b(a) {
		cout << "拷贝构造函数" << endl;
	}

	// 析构函数在对象销毁前  编译器调用析构函数
	~Maker() {
		cout << "析构函数" << endl;
	}

private:
	int a;
	BMW b;// 成员对象
	Buick bu;// 成员对象
};


void test() {
	Maker m;
}

void test2() {

}


int main() {
	// 封装
	test();
	
	system("pause");
	return EXIT_SUCCESS;
}
```


## 对象的深拷贝和浅拷贝

**默认的拷贝构造函数进行了简单的赋值操作，这个是浅拷贝**


浅拷贝案例
```cpp

# define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include "test.h"
using namespace std;



class Maker {
public:
	Maker(int id, int age) {
		mId = id;
		mAge = age;
	}

	int getId() {
		return mId;
	}

	int getAge() {
		return mAge;
	}
	
private:
	int mId;
	int mAge;
};

void test() {
	Maker m1(1, 11);
	Maker m2(m1);

	cout << "m1 " << m1.getId() << endl;
	cout << "m2 " << m2.getAge() << endl;

}
int main() {
	// 封装
	test();
	
	system("pause");
	return EXIT_SUCCESS;
}
```


**深拷贝**
**说白了就是在申请一块内存空间，然后把原来的值拷贝进去**

```cpp
class Student {
public:
	Student(const char* name, int Age) {
		pName = (char*)malloc(strlen(name) + 1);
		strcpy(pName, name);
		age = Age;
	}

	// 深拷贝  拷贝构造函数  也就是先申请空间  然后拷贝
	Student(const Student& stu) {
		cout << "自己拷贝的构造函数" << endl;
		// 申请空间
		pName = (char*)malloc(strlen(stu.pName) + 1);
		// 拷贝数据
		strcpy(pName, stu.pName);
		age = stu.age;
	}

	~Student() {
		cout << "析构函数" << endl;
		if (pName != NULL) {

			free(pName);
			pName = NULL;
		}
	}

private:
	char* pName;
	int age;
};

```

