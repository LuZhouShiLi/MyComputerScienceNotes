# 信号和槽

## 简单介绍


**connect(信号的发送者，发送的具体信号，信号的接收者，信号的处理槽函数)**

**信号槽函数的优点，松散耦合，信号发送端和接收端 本身都没有关联的，通过connect连接 将两端耦合在一起**

## 举例子-点击按钮关闭窗口

```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "mypush.h"
#include <QPushButton>


// 构造函数 使用初始化列表 初始化继承的QMainWindow类
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    // 创建一个自己的按钮对象
    MyPush *mp = new MyPush;
    mp->setText("我自己的按钮");
    mp->move(200,0);
    mp->setParent(this);
    // 点击按钮 关闭窗口
    // 信号的发送者  发送的信号 其实就是一个函数的地址   信号的接收者  处理的槽函数
    connect(mp,&MyPush::clicked,this,&QMainWindow::close);
}

MainWindow::~MainWindow()
{
    delete ui;
}

```


## 自定义信号和槽函数

**场景：Teacher类  老师类 Student 学生类 下课后，老师会触发一个信号，饿了，学生响应信号，请客吃饭**

Teacher类

```cpp
#ifndef TEACHER_H
#define TEACHER_H

#include <QObject>

// 继承QObeject
class Teacher : public QObject
{
    Q_OBJECT
public:
    explicit Teacher(QObject *parent = nullptr);

signals:
    // 自定义信号 写道Signals下
    // 返回值是void  只需要声明  不需要实现
    // 可以有参数 可以进行重载
    void hungry();

public slots:

};

#endif // TEACHER_H

```

```cpp

#include "teacher.h"

Teacher::Teacher(QObject *parent)
    : QObject{parent}
{

}

```


学生类

```cpp
#ifndef STUDENT_H
#define STUDENT_H

#include <QObject>

class student : public QObject
{
    Q_OBJECT
public:
    explicit student(QObject *parent = nullptr);

signals:

public slots:
    // 返回值void 需要声明  也需要实现
    // 可以有参数 可以发生重载
    void treat();

};

#endif // STUDENT_H


```



```cpp
#include "student.h"
#include<QDebug>

// 继承QObject
student::student(QObject *parent)
    : QObject{parent}
{

}

// 实现槽函数
void student::treat(){
    qDebug()<<"请老师吃饭";
}


```

mainwindow.h

```cpp
// 防止头文件重复编译
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
#include <QMainWindow>
#include "teacher.h"
#include "student.h"

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

// 继承QMainWindow类
class MainWindow : public QMainWindow
{
    //宏 允许类中使用信号和槽的机制
    Q_OBJECT

public:
    // 默认有参构造函数
    MainWindow(QWidget *parent = nullptr);
    // 析构函数
    ~MainWindow();

private:
    Ui::MainWindow *ui;

    // 定义两个私有成员变量
    Teacher *zt;
    student *st;
    
    // 条件
    void ClassIsOver();
};
#endif // MAINWINDOW_H


```

```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "mypush.h"

#include <QPushButton>


// 构造函数 使用初始化列表 初始化继承的QMainWindow类
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);


    // 创建一个自己的按钮对象
    MyPush *mp = new MyPush;
    mp->setText("我自己的按钮");
    mp->move(200,0);
    mp->setParent(this);

    // 点击按钮 关闭窗口
    // 信号的发送者  发送的信号 其实就是一个函数的地址   信号的接收者  处理的槽函数
    connect(mp,&MyPush::clicked,this,&QMainWindow::close);


    // 创建一个老师对象
    this->zt = new Teacher(this);

    // 创建一个学生对象
    this->st = new student(this);

    // 老师饿了信号  学生请客的连接的槽函数
    connect(zt,&Teacher::hungry,st,&student::treat);
    
    ClassIsOver();// 调用下课函数 然后触发老师饿了的信号  然后调用学生请客吃饭的槽函数



}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::ClassIsOver(){
    // 下课函数  调用之后 出发老师饿了的信号  
    // 发射信号
    emit zt->hungry();
}

```

## 自定义信号和槽携带参数

**需要使用函数指针，明确指向函数的地址**

student

```cpp
#ifndef STUDENT_H
#define STUDENT_H

#include <QObject>

class student : public QObject
{
    Q_OBJECT
public:
    explicit student(QObject *parent = nullptr);

signals:

public slots:
    // 返回值void 需要声明  也需要实现
    // 可以有参数 可以发生重载
    void treat();

    // 信号发生重载 对应的槽函数也是发生重载
    void treat(QString foodName);



};

#endif // STUDENT_H


```

```cpp
#include "student.h"
#include<QDebug>

// 继承QObject
student::student(QObject *parent)
    : QObject{parent}
{

}

// 实现槽函数
void student::treat(){
    qDebug()<<"请老师吃饭";
}


void student::treat(QString foodName){
    qDebug()<<"请老师吃饭"<<foodName;
}

```

```cpp
#ifndef TEACHER_H
#define TEACHER_H

#include <QObject>

// 继承QObeject
class Teacher : public QObject
{
    Q_OBJECT
public:
    explicit Teacher(QObject *parent = nullptr);

signals:
    // 自定义信号 写道Signals下
    // 返回值是void  只需要声明  不需要实现
    // 可以有参数 可以进行重载
    void hungry();

    // 重载信号
    void hungry(QString foodName);

public slots:

};

#endif // TEACHER_H



```

```cpp
#include "teacher.h"

Teacher::Teacher(QObject *parent)
    : QObject{parent}
{

}


```

mainWindow

```cpp

// 防止头文件重复编译
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
#include <QMainWindow>
#include "teacher.h"
#include "student.h"

QT_BEGIN_NAMESPACE
namespace Ui { class MainWindow; }
QT_END_NAMESPACE

// 继承QMainWindow类
class MainWindow : public QMainWindow
{
    //宏 允许类中使用信号和槽的机制
    Q_OBJECT

public:
    // 默认有参构造函数
    MainWindow(QWidget *parent = nullptr);
    // 析构函数
    ~MainWindow();

private:
    Ui::MainWindow *ui;

    // 定义两个私有成员变量
    Teacher *zt;
    student *st;

    // 条件
    void ClassIsOver();
};
#endif // MAINWINDOW_H

```


```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "mypush.h"

#include <QPushButton>


// 构造函数 使用初始化列表 初始化继承的QMainWindow类
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    // 创建一个自己的按钮对象
    MyPush *mp = new MyPush;
    mp->setText("我自己的按钮");
    mp->move(200,0);
    mp->setParent(this);

    // 点击按钮 关闭窗口
    // 信号的发送者  发送的信号 其实就是一个函数的地址   信号的接收者  处理的槽函数
    connect(mp,&MyPush::clicked,this,&QMainWindow::close);


    // 创建一个老师对象
    this->zt = new Teacher(this);

    // 创建一个学生对象
    this->st = new student(this);

    // 带参数的信号和槽函数
    void(Teacher:: *teacherSignal)(QString) = &Teacher::hungry;
    void(student:: *studentSlot)(QString) = &student::treat;

    // 老师饿了信号  学生请客的连接的槽函数
    connect(zt,teacherSignal,st,studentSlot);

    ClassIsOver();// 调用下课函数 然后触发老师饿了的信号  然后调用学生请客吃饭的槽函数
}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::ClassIsOver(){
    // 下课函数  调用之后 出发老师饿了的信号
    emit zt->hungry("红烧肉");// 发射带参数的信号
}

```


## 信号连接信号-点击下课按钮 触发下课信号 发射老师饿了的信号

**下面的思路是，点击按钮，clicked信号连接ClassIsOver的槽函数，之后发射老师饿了的信号，执行学生请客吃饭的槽函数**


```cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "mypush.h"

#include <QPushButton>


// 构造函数 使用初始化列表 初始化继承的QMainWindow类
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);


    // 创建一个自己的按钮对象
    MyPush *mp = new MyPush;
    mp->setText("我自己的按钮");
    mp->move(200,0);
    mp->setParent(this);

    // 点击按钮 关闭窗口
    // 信号的发送者  发送的信号 其实就是一个函数的地址   信号的接收者  处理的槽函数
    connect(mp,&MyPush::clicked,this,&QMainWindow::close);


    // 创建一个老师对象
    this->zt = new Teacher(this);

    // 创建一个学生对象
    this->st = new student(this);

    // 带参数的信号和槽函数
    void(Teacher:: *teacherSignal)(QString) = &Teacher::hungry;
    void(student:: *studentSlot)(QString) = &student::treat;

    // 老师饿了信号  学生请客的连接的槽函数
    connect(zt,teacherSignal,st,studentSlot);

    ClassIsOver();// 调用下课函数 然后触发老师饿了的信号  然后调用学生请客吃饭的槽函数

    // 点击一个下课的按钮 然后在触发下课

    QPushButton *btn = new QPushButton(
                "下课了",this);

    // 点击按钮 触发下课  然后发射老师饿了的信号  然后执行学生请客吃饭的槽函数
    connect(btn,&QPushButton::clicked,this,&MainWindow::ClassIsOver);

}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::ClassIsOver(){
    // 下课函数  调用之后 出发老师饿了的信号
    emit zt->hungry("红烧肉");// 发射带参数的信号
}

```


**改进一下，信号连接信号：点击按钮，发射老师饿了的信号，相当于clicked信号连接hungry信号，然后执行学生请客的槽函数**

```cpp

#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "mypush.h"

#include <QPushButton>


// 构造函数 使用初始化列表 初始化继承的QMainWindow类
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);


    // 创建一个自己的按钮对象
    MyPush *mp = new MyPush;
    mp->setText("我自己的按钮");
    mp->move(200,0);
    mp->setParent(this);

    // 点击按钮 关闭窗口
    // 信号的发送者  发送的信号 其实就是一个函数的地址   信号的接收者  处理的槽函数
    connect(mp,&MyPush::clicked,this,&QMainWindow::close);


    // 创建一个老师对象
    this->zt = new Teacher(this);

    // 创建一个学生对象
    this->st = new student(this);

    // 带参数的信号和槽函数
    void(Teacher:: *teacherSignal)(QString) = &Teacher::hungry;
    void(student:: *studentSlot)(QString) = &student::treat;

    // 老师饿了信号  学生请客的连接的槽函数
    connect(zt,teacherSignal,st,studentSlot);

    ClassIsOver();// 调用下课函数 然后触发老师饿了的信号  然后调用学生请客吃饭的槽函数

    // 点击一个下课的按钮 然后在触发下课

    QPushButton *btn = new QPushButton(
                "下课了",this);

    // 点击按钮 触发下课  然后发射老师饿了的信号  然后执行学生请客吃饭的槽函数
//    connect(btn,&QPushButton::clicked,this,&MainWindow::ClassIsOver);


    // 信号连接信号
    // 无参数的信号和槽函数
    void(Teacher:: *teacherSignal2)(void) = &Teacher::hungry;
    void(student:: *studentSlot2)(void) = &student::treat;
    connect(zt,teacherSignal2,st,studentSlot2);

    // 老师饿了信号  学生请客的连接的槽函数  点击按钮 发射老师饿了的信号  信号连接信号
    connect(btn,&QPushButton::clicked,zt,teacherSignal2);
    
    // 断开信号
    disconnect(zt,teacherSignal2,st,studentSlot2);
}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::ClassIsOver(){
    // 下课函数  调用之后 出发老师饿了的信号
    emit zt->hungry("红烧肉");// 发射带参数的信号
}


```







