# 多线程

## 概述

* 并发和并行

![图 1](../images/fe0f07d2e94de725c3ad63ae3113119b3f3c3becb80c47b16b3ad6f4fe88cced.png)  

* 进程和线程

![图 2](../images/a75326464022bc275715e04037deb87e2dd0cd5f7ff0a751225519994002b452.png)  

## 读线程实现方式-继承Thread

![图 3](../images/4c3161ba3ca56defcdf02ca8ebaca6c6fbe346f837d166321b6e3ceba16bafa8.png)  


* 继承Thread类进行实现

![图 4](../images/af92197f03bbb23436893b6221e1b29c4fb6fa701b9f11f3265928abf36ac3c5.png)  

```java
package com.hfut.edu.test11;

public class MyThread extends Thread{

    // 重写run方法
    @Override
    public void run() {
        super.run();

        for (int i = 0; i < 100; i++) {
            System.out.println("线程开启了" + i);
        }
    }
}


```

```java
package com.hfut.edu.test11;

public class test1 {
    public static void main(String[] args) {
        MyThread  m1 = new MyThread();
        m1.start();// 开启一个线程

        MyThread m2 = new MyThread();
        m2.start();
        // 线程交替执行
    }
}
```

**run方法与start方法的区别：run方法表示的仅仅是创建对象，使用对象去调用方法，并没有开启线程，使用start方法开启线程**

![图 5](../images/9710a706f4a65619e392d294e621154d021de6ef7cccbdd976e4a2d30bdeb9ce.png)  

**start方法启动线程；然后使用JVM调用此线程的run()方法**

* 开启多线程实现方式-runable接口

![图 6](../images/88018eb820058c9a78b8e5e62423bbeed660f51190a71459e317419ff0cd6e04.png)  

实现Runable 接口

```java
package com.hfut.edu.test11;

public class MyRunable implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("第二种多线程的实现" + i);
        }
    }
}


```


```java
package com.hfut.edu.test11;

public class tewts2 {
    public static void main(String[] args) {
        // 创建一个参数对象
        MyRunable mr = new MyRunable();
        // 创建线程对象 将参数传递给这个线程
        Thread t1 = new Thread(mr);
        t1.start();


        MyRunable mr1 = new MyRunable();
        Thread t2 = new Thread(mr1);
        t2.start();

        // 线程交替执行
    }
}


```

## 多线程实现方式-Callable

![图 7](../images/bd4c025be3be6e41b8ad47315d1d0bacf735bcec0f9cfe984fa5326df064fb7d.png)  

```java
package com.hfut.edu.test11;

import java.util.concurrent.Callable;

public class MyCallable implements Callable<String> {

    // 实现call 方法
    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println("hhhhhhhh" + i);
        }
        return "xxxx";
    }
}


```

```java
package com.hfut.edu.test11;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Demo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyCallable mc = new MyCallable();
        FutureTask<String> ft = new FutureTask<>(mc);// 可以获取线程执行完毕之后的结果
        Thread t1 = new Thread(ft);
        t1.start();

        String s = ft.get();// 获取线程执行之后的结果
        System.out.println(s);
    }
}


```

## 三种实现方式的对比

![图 8](../images/d1528ac3fda824f61f32a41775bdcf32eae5c37bc5deeeabba4c5dd20073afd7.png)  

## Thread方法

* 获取线程名称

```java
package com.hfut.edu.test11;

public class MyThread extends Thread{

    // 重写run方法
    @Override
    public void run() {
        // 获取线程的名称
        String name = getName();
        System.out.println(name);
    }
}
```

* 获取当前线程

```java
package com.hfut.edu.test11;

public class MyThread extends Thread{

    // 重写run方法
    @Override
    public void run() {
        // 获取线程的名称
        Thread t = Thread.currentThread();// 静态方法调用
        System.out.println(t);
    }
}


```

* 多线程的带参数构造方法

```java
package com.hfut.edu.test11;

public class MyThread extends Thread{

    public MyThread(){}

    public MyThread(String name){
        super(name);// 设置线程的名称
    }

    // 重写run方法
    @Override
    public void run() {
        // 获取线程的名称
        Thread t = Thread.currentThread();// 静态方法调用
        System.out.println(t.getName());// 打印线程的名字
    }
}

```

* Sleep方法

```java
package com.hfut.edu.test11;

public class test3 {
    public static void main(String[] args) throws InterruptedException {
        for (int i = 1; i < 61; i++) {
            System.out.println(i);
            Thread.sleep(1000);// 程序休眠1s
        }


    }
}
```

## 守护线程

* 当守护线程执行完毕，其他线程也就没有执行下去的必要


![图 9](../images/f5f8cc60e94e3417c106215132b5518eafa8376688c7a346a77a1f63cf640f22.png)  

```java
package com.hfut.edu.test11;

public class test4 {
    public static void main(String[] args) {
        MyThread1 m1 = new MyThread1();
        MyThread2 m2 = new MyThread2();

        m1.setName("主线程");
        m2.setName("其他线程");

        m1.setDaemon(true);// 主线程执行完毕 其他线程直接结束

        m1.start();
        m2.start();
    }
}

```

## 线程的优先级

![图 10](../images/972782fc53280493fc6d2face92f431a8987378906e60c671286657afd6f4355.png)  

* 优先级更高 抢到CPU的几率更高


```java
package com.hfut.edu.test11;

public class test4 {
    public static void main(String[] args) {
        MyThread1 m1 = new MyThread1();
        MyThread2 m2 = new MyThread2();

        m1.setName("主线程");
        m2.setName("其他线程");

        m1.setDaemon(true);// 主线程执行完毕 其他线程直接结束

        m1.start();
        m2.start();

        System.out.println(m1.getPriority());// 打印线程的优先级   默认优先级5
        System.out.println(m2.getPriority());//
        
        m1.setPriority(6);
        m2.setPriority(7);// 设置线程的优先级
    }
}


```

