# 抽象类

## 一、概述

![图 1](../images/c1d7c129b0914188e9b838120815f2ab25dc2baf809c173c3bd407c4410bbcaa.png)  

* 抽象方法：将共性的方法抽取到父类之后，发现该方法的实现逻辑无法在父类中给出具体明确，该方法就可定义为抽象方法
* 抽象类：如果一个类中存在抽象方法，该类必须声明为抽象类

![图 2](../images/f91830f035f2cc8af12754e0129d107d2e064eaa82fb06e12381c314b5e2e4ca.png)  


Animal抽象类：
```java
package com.hfut.test;

public abstract class Animal {
    // 动物抽象类

    public void drink(){
        System.out.println("喝水");
    }

    public abstract void eat();// 将eat方法抽象成 抽象方法 抽象方法只存在于抽象类中

}


```

cat
```java
package com.hfut.test;

public class Cat extends Animal{
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }
}


```


dog
```java
package com.hfut.test;

public class Dog extends Animal{
    @Override
    public void eat() {
        // 继承抽象类 必须实现抽象方法
        System.out.println("狗吃肉");
    }
}

```

## 二、抽象类注意事项

* 抽象类不可创建对象

![图 3](../images/b6f0abc3115567125824f9cfd104bf912bd2b252d483bcd230dfab28c1a54022.png)  

* 抽象类中存在构造方法

![图 4](../images/0f80c2cc0c69051c2b9460e23c0ec66880dbd4f0bc7c30ac1c27af6b07d2f69a.png)  

* 抽象类的子类
  * 必须重写父类中所有抽象方法
  * 自己也可以变成抽象方法


* 抽象类中可以没有抽象方法 有抽象方法的一定是抽象类

## 三、模板设计模式

![图 5](../images/e03a55c008541f9433cceba8bfdc2a34f5d027779d49f892fa2efa247c027c30.png)  

```java
package com.hfut.Template;

public abstract class Composition {

    public void write(){
        System.out.println("xxxxxxxxx");

        body();// 抽象方法

        System.out.println("xxxxxxxxxxx");
    }

    public abstract void body();// 抽象方法
}


```

![图 6](../images/4eae23ffc60b4cdb3ee0d72738440a56ac4fcfab316252cd15bf8464c031e5f2.png)  


## 四、final关键字

![图 7](../images/741d3953bdede2c05010bb2cf8d093f863840dc1248fd5851c21a61444041326.png)  

* 使用该关键字修饰的方法是最终的方法，不可以被重写

* 修饰常量，子类不可进行重新赋值

* 修饰类：该类是最终类 不可以被继承

对于final修饰的变量：

* 基本数据类型变量：不可以被重新赋值
* 引用数据类型变量：地址值不可以被更改 但是可以修改属性值
  ![图 8](../images/d7b1e0137877cd759b9c689cb3bbf15e9e0ca3334645e2f70c562ff6458525b4.png)  


* final修饰的成员变量：初始化时机
  * 在创建的时候 直接给值  推荐
  * 在构造方法结束之前 完成赋值

## 五、代码块

![图 9](../images/6078f09ca5428c57b156ef37ecfd6a9d7f1575916542c5f29c995c5e29a4cc19.png)  

* 局部代码块：在方法中定义，限定变量的声明周期，尽早释放，提高内存利用率

* 构造代码块：类中方法外定义，每次构造方法执行的时候，都会执行该代码块中的代码，并且在构造方法执行前执行，作用：将多个重载的构造方法中相同的代码，抽取到构造代码块中，提高代码的复用性

![图 10](../images/6e92edf7c0ae0cc793c6f0c575053ae77b1bdc795ce75a64f69b89d06418a643.png)  

静态代码块：位置：类中方法外部定义，特点：需要通过static 关键字进行修饰，随着类的加载而加载，并且只执行一次  作用：在类加载的时候做一些数据初始化的操作

![图 11](../images/9d8bae14244b58c0f67905db49956a813c4a19d4cd5ef288c8d420788ef6e7aa.png)  


