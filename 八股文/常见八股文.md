# 字节跳动



## 字节飞书 后端开发 日常实习 25届 面经


### redis的基础结构
&emsp;
Redis（REmote DIctionary Server）是一个开源的内存数据存储系统，通常被用作缓存、消息队列和键值存储。它支持多种数据结构，每种数据结构都有其独特的用途。以下是 Redis 的基础数据结构：

* 字符串（String）:Redis 的最基本数据类型，可以存储字符串、整数或者浮点数。常见操作包括设置值、获取值、对字符串进行追加、递增递减等。
* 哈希表（Hash）:Redis 的哈希表类似于其他编程语言中的字典或关联数组。存储字段和与其关联的值，适用于存储对象。
* 列表（List）:有序的字符串元素集合，支持从两端进行元素的推入（push）和弹出（pop）。可以用作队列或栈
* 集合（Set）:无序的唯一字符串元素的集合，不允许重复的元素。
常见的集合操作包括添加、删除、查找元素

* 位图（BitMap）:Redis 的位图是一种特殊的数据结构，可以用来处理位级别的操作，如计算用户的在线状态等。
* HyperLogLog:用于基数（cardinality）估算的数据结构


### sorted set 如何实现


跳表：Sorted Set 是 Redis 中一种有序的集合数据结构，每个元素都与一个分数（score）关联，根据分数的大小进行排序。在 Sorted Set 中，元素是唯一的，但分数可以重复。

实现 Sorted Set 主要依赖于跳跃表（Skip List）和哈希表这两种数据结构的组合。以下是 Sorted Set 的基本实现原理


* 跳跃表（Skip List）:

&emsp;跳跃表是一种有序的数据结构，其中每个节点包含多个指向其他节点的指针，这使得在查找元素时可以跳跃部分节点，从而提高查找效率。
在 Redis 中，Sorted Set 使用跳跃表作为底层的有序数据结构，以支持快速的查找、插入和删除操作。


* 哈希表（Hash Table）:

&emsp;为了实现元素的唯一性，每个元素都会在一个哈希表中进行存储，其中键是元素的值，而值是元素的分数。哈希表用于保证元素的唯一性和快速的查找操作。通过跳跃表和哈希表的结合，Sorted Set 实现了高效的插入、删除和查找操作，并且能够保持元素的有序性。当执行插入或删除操作时，跳跃表和哈希表需要同时更新以维护有序性和唯一性。


* 跳跃表是用来维护有序集合中的成员的。在有序集合中，每个成员都有一个分数（score），而跳跃表则根据这个分数来排序成员。跳跃表通过多级索引，可以在平均情况下实现 O(log n) 的插入、删除和查询操作



## 计算机网络


### TCP和UDP的报文格式

```java
TCP 报文格式：
TCP 报文格式相对较复杂，包含以下字段：

源端口（Source Port）: 16 bits

标识发送方的端口号。
目标端口（Destination Port）: 16 bits

标识接收方的端口号。
序列号（Sequence Number）: 32 bits

用于对数据流中的每个字节进行编号，用于顺序重组数据。
确认号（Acknowledgment Number）: 32 bits

如果设置了 ACK 标志位，则表示期望接收的下一个序列号。
数据偏移（Data Offset）: 4 bits

表示 TCP 头部的长度，以 32 位字为单位。
保留（Reserved）: 6 bits

保留字段，用于将来使用，目前置为0。
控制标志（Control Flags）: 6 bits

包括 URG、ACK、PSH、RST、SYN、FIN 这六个标志位。
窗口大小（Window Size）: 16 bits

表示接收方能够接收的数据的窗口大小。
校验和（Checksum）: 16 bits

用于检测头部和数据的错误。
紧急指针（Urgent Pointer）: 16 bits

仅在 URG 标志被设置时才有效，指明紧急数据的末尾。
选项（Options）: （可变长度）

包含一些可选字段，如最大段大小（MSS）、时间戳（Timestamps）等。
数据（Data）: （可变长度）

包含应用层传输的数据。


```


```java
UDP 报文格式：
UDP 报文相对简单，包含以下字段：

源端口（Source Port）: 16 bits

标识发送方的端口号。
目标端口（Destination Port）: 16 bits

标识接收方的端口号。
长度（Length）: 16 bits

包括 UDP 头和数据的总长度。
校验和（Checksum）: 16 bits

用于检测头部和数据的错误。
数据（Data）: （可变长度）

包含应用层传输的数据。

```


## TCP与UDP的主要区别
TCP 专注于高效可靠的数据传输:通过握手建立会话,从而成功传递数据,如果数据包传输失败，则重新发送。TCP 还将使用数据包排序，将大量数据分成更小的单元，以确保信息成功发送，并在移动到下一个数据包之前收到确认。

UDP 在发送数据时不会停止确认:也不一定会重新发送丢失的数据包,它缺乏错误监控的权衡是速度的提高——在这个过程中可能会丢失一些信息。

可以理解为:**TCP 专注于可靠、准确的数据传输，并以速度为代价，UDP 做相反的事情并优先考虑速度，并且不为数据包排序或传输提供保证，在安全方面UDP 也可能更容易 受到分布式拒绝服务 (DDoS) 攻击。**


### Http的get和post

#### get

* GET 请求用于从服务器获取资源，不应该对服务器产生副作用。
请求参数通常附加在 URL 的查询字符串中，可见于请求的地址栏。
* GET 请求对于传输数据量有限制，因为请求参数是附加在 URL 上的。
GET 请求可以被缓存，可以被书签保存，且对搜索引擎可见。不适合用于敏感信息传输，因为参数直接暴露在 URL 上。


#### post


* POST 请求用于向服务器提交数据，可以对服务器产生副作用，比如提交表单、上传文件等。请求参数通常包含在请求体中，而不是在 URL 上。
* POST 请求没有数据量的限制，因为参数包含在请求体中。
* POST 请求不会被缓存，不会被书签保存，对搜索引擎不可见。
* 适合用于传输敏感信息，因为参数不会直接暴露在 URL 上


#### 注意事项

幂等性：

GET 请求是幂等的，即对同一资源的多次请求应该产生相同的结果。但是 POST 请求不是幂等的，多次请求可能会产生不同的结果。
安全性：

GET 请求是安全的，不应该对服务器状态产生影响。POST 请求可能对服务器状态产生影响，因为它通常用于提交数据。
可见性：

GET 请求的参数在 URL 中可见，可能被浏览器记录或保存。POST 请求的参数在请求体中，相对更安全。


```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class GetController {

    @GetMapping("/hello")
    public String getHello(@RequestParam(name = "name", defaultValue = "Guest") String name) {
        return "Hello, " + name + "!";
    }
}


```
* hello 路径下定义了一个 GET 请求的接口。通过 @RequestParam 注解，可以接收请求参数，并在方法体内处理。例如，访问 /hello?name=John 将返回 "Hello, John!"

```java
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class PostController {

    @PostMapping("/greet")
    public String postGreet(@RequestBody String name) {
        return "Greetings, " + name + "!";
    }
}


```

* 上面的例子中，/greet 路径下定义了一个 POST 请求的接口。通过 @RequestBody 注解，可以接收请求体中的数据，并在方法体内处理。例如，向 /greet 发送 POST 请求，请求体为 "John" 将返回 "Greetings, John!"。

## 操作系统页面置换算法


&emsp;在操作系统中，当程序需要访问的页面不在内存中时，会发生缺页中断（Page Fault），操作系统需要将缺失的页面调入内存。如果内存已满，就需要进行页面置换，选择一个页面将其从内存中移出，腾出空间加载新的页面。这一过程可能触发页面置换算法。



* 最佳置换算法（Optimal Replacement）：这是一种理想化的算法，它选择被访问时间最远的页面进行置换。理论上，这是一种能够最小化缺页次数的算法。然而，在实际情况中，由于无法预知未来的页面访问情况，最佳置换算法很难实现。

* 先进先出算法（FIFO - First-In-First-Out）：FIFO 算法选择最早进入内存的页面进行置换。它维护一个队列，当发生页面置换时，选择队列中最早进入的页面移出。FIFO 算法简单易实现，但可能导致 Belady's Anomaly，即在增加内存时，缺页次数反而增多。
  
* 最近最久未使用算法（LRU - Least Recently Used）：LRU 算法选择最长时间未被使用的页面进行置换。实现 LRU 需要维护一个访问历史记录，当页面被访问时，将其移到历史记录的最前面。LRU 算法相对较为复杂，但在一定程度上能够较好地反映程序的局部性原理。
* 时钟算法（Clock）：时钟算法通过使用一个类似时钟的数据结构，维护一个指针指向内存中的页面。当发生缺页时，从指针指向的页面开始扫描，找到第一个未被访问的页面进行置换。这个算法在实现上相对简单，并且在一定程度上能够平衡性能和实现难度。
* 最不常用算法（LFU - Least Frequently Used）：LFU 算法选择最少被访问的页面进行置换。它维护每个页面的访问次数，并在发生缺页时选择访问次数最小的页面进行置换。LFU 算法的实现相对复杂，但能够较好地适应一些特定的工作负载。

## 抽象类和接口


```java
定义：

抽象类是一个包含抽象方法的类，它本身不能被实例化，需要子类继承并实现其中的抽象方法。
特点：

抽象类可以包含非抽象方法（具体方法）。
可以包含实例变量。
子类只能继承一个抽象类。
使用场景：

当需要在基类中提供一些默认的实现，并且希望子类有选择性地覆盖这些实现时，可以使用抽象类。
当你想要共享代码，但也要求子类提供某些特定实现时，抽象类是一个好的选择。

```


```java

定义：

接口是一个完全抽象的类，它只包含抽象方法和常量字段。
特点：

接口中的方法默认是公共的抽象方法（Java 8 之后，可以包含默认方法和静态方法）。
接口中不能包含实例变量。
一个类可以实现多个接口。
使用场景：

当需要定义一组方法，但不提供任何实现时，可以使用接口。
当一个类需要实现多个不相关的类型或行为时，接口提供了一种多继承的解决方案。
当希望定义可插拔的组件时，接口可以提供一种规范，让多个类实现相同的接口。
```


```java
使用抽象类：

当你需要在基类中提供一些通用的实现，并且希望子类有选择性地覆盖这些实现时。
当需要包含实例变量或构造函数时。
使用接口：

当你需要定义一组方法，但不提供任何实现时。
当一个类需要实现多个不相关的类型或行为时。
当你希望定义可插拔的组件，并希望多个类实现相同的接口

```

* 在实际开发中，我们需要根据具体的业务场景来选择使用继承或者接口。一般来说，如果我们需要定义一个新的类，它具有父类的所有属性和方法，并且需要在此基础上扩展一些新的属性和方法，那么我们应该使用继承。而如果我们需要定义一个新的类，它需要具有某种能力或者实现某种规范，那么我们应该使用接口。当然，有些情况下也可以同时使用继承和接口，根据具体情况来灵活组合使用。


```java
继承是指子类从父类继承属性和方法，子类可以重写父类的方法，实现对父类的扩展。继承通常用于实现 is-a 关系，即子类是父类的一种类型，且子类可以继承父类的所有属性和方法。当我们需要在已有类的基础上进行扩展，添加一些新的功能时，继承是一个很好的选择。

接口是一种定义行为规范的抽象类型，它只定义了方法的声明，而没有实现。接口中定义的方法，必须由实现该接口的类去具体实现，接口主要用于实现多态，即不同的类可以实现同一个接口，并根据自身的需求进行实现。当我们需要实现多种不同的行为规范时，接口是一个很好的选择。

通常情况下，我们会优先考虑使用接口，因为它更加灵活，支持多态性和模块化开发。当我们需要定义一组规范，而不关心具体实现时，接口是一个很好的选择。而当我们需要在已有类的基础上进行扩展，添加新的功能时，继承是一个很好的选择。

当然，有时候我们也可以将继承和接口结合起来使用，例如实现一个抽象类，既包含一些具体实现，又定义了一些抽象方法，让其子类实现。无论如何，我们需要根据具体的需求，合理选择继承和接口，以达到更好的代码复用和灵活性。


```

* 接口主要用于实现多态，即不同的类可以实现同一个接口，并根据自身的需求进行实现。当我们需要实现多种不同的行为规范时，接口是一个很好的选择。
* 当我们需要定义一组规范，而不关心具体实现时，接口是一个很好的选择。而当我们需要在已有类的基础上进行扩展，添加新的功能时，继承是一个很好的选择。

## 字节懂车帝 后端开发 日常实习 25届 面经


### MySQL的缓存一致性

* 先写缓存，再写数据库：如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。这样缓存中的数据就变成脏数据，这个问题非常严重，也是最差的一种解决方案。
* 方案二：先写数据库，再写缓存：问题又来了，写数据库成功，但写缓存失败了，依然会造成缓存脏数据的问题。
* 在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。
* 方案三：先删缓存，再写数据库： 存在并发问题，先删除缓存，可能另外一个线程先读取了数据库的脏数据，然后写入缓存中
* 方案四：先写数据库，再删缓存：也可能造成不一致，但是几率比较小
* 删除缓存失败怎么办：设置过期时间，同步重试，消息队列：将删除缓存任务写入mq等消息中间件。在mq的consumer中处理：
* 延时双删，延时双删可以解决上面的问题，只要sleep的时间大于线程2读取数据再写入缓存的时间就可以了，也就是线程1的二次清缓存操作要在线程2写入缓存之后，这样才能保证Redis缓存中的数据是最新的。


### redis如何实现分布式锁

&emsp;Redis可以通过使用SET命令结合NX（Not Exists）和EX（Expiration）选项来实现简单的分布式锁。以下是一个基本的Redis分布式锁的实现示例：


### select和epoll有那些区别

### 打开浏览器输入url


* DNS解析（Domain Name System）：浏览器首先会将输入的URL解析为IP地址。如果在本地缓存中找到对应的IP地址，则直接使用；否则，浏览器会向本地DNS服务器发起请求，逐级向上查找，直至找到对应的IP地址。
* 建立TCP连接：浏览器使用HTTP或HTTPS协议，通过TCP连接与目标服务器建立联系。这包括通过三次握手建立连接。
* 发起HTTP请求：浏览器向服务器发送HTTP请求，请求页面的资源。请求可以包括HTML、CSS、JavaScript文件、图片等。
* 服务器处理请求：服务器接收到请求后，根据请求的URL和其他信息，进行相应的处理。这可能涉及到读取数据库、执行业务逻辑等操作。
* 服务器响应：服务器将处理结果封装成HTTP响应，返回给浏览器。响应可能包括HTML文档、CSS样式表、JavaScript脚本以及其他媒体文件。
* 浏览器渲染：浏览器接收到服务器的响应后，开始解析HTML文档，构建DOM（Document Object Model）树。然后，根据DOM树和CSS样式表生成渲染树，最终绘制页面。
* JavaScript执行：如果HTML文档包含了JavaScript代码，浏览器会执行这些脚本。执行过程中可能会修改DOM树、触发重新渲染，或者进行异步请求获取更多资源。
页面加载完成：

当所有资源加载完成，页面渲染完成，触发 onload 事件。此时，用户可以与页面进行交互

### 为什么TCP是三次握手


```java
客户端发送连接请求：

客户端发送一个带有SYN（同步）标志的TCP报文段，表明客户端想要建立连接，并选择一个初始序列号（ISN）。
服务器响应连接请求：

服务器收到客户端的连接请求后，回应一个带有ACK（确认）和SYN标志的TCP报文段，表明服务器同意建立连接，同时也选择一个初始序列号。
客户端发送连接确认：

客户端收到服务器的响应后，再发送一个带有ACK标志的TCP报文段，表明客户端确认连接建立。至此，连接就正式建立。

```

* 建立连接的可靠性：

三次握手可以确保双方都能够正常接收对方的连接请求，并且双方都认可对方的接收能力。这样一来，就避免了类似于网络中的延迟、丢包等问题可能导致的不确定性。通过三次握手，建立连接的过程更为可靠。

* 防止已失效的连接请求报文段产生错误：

假设只使用两次握手，客户端发送连接请求，但因为网络延迟或其他原因导致该请求在某个网络节点滞留，未及时达到服务器。此时，服务器没有收到连接请求，但客户端认为连接已经建立。如果此时客户端开始传输数据，而服务器并不知道连接已建立，就可能导致错误。


### HTTPS的过程

* TCP三次握手
* TLS四次挥手
* HTTP通信
* TCP四次挥手

### TLS的四次握手

* 客户端发出请求 hello
  * 支持的协议版本 TLS 1.0
  * 一个客户端生成的随机数 用于生成对话密钥
  * 支持的加密方法 比如RSA公钥加密
  * 支持的压缩方法
* 服务器回应 Hello
  * 确认使用的加密通信协议版本 TSL 如果浏览器和服务器支持的版本不一致 服务器关闭加密通信
  * 确认使用的加密方法 比如RSA公钥加密 返回加密公钥
  * 服务器证书
* 客户端回应
  * 验证证书的合法性
  * 如果信任该证书，会使用证书中的公钥进行密钥交换。客户端生成一个随机的对称密钥（Pre-Master Secret），使用服务器的公钥加密，并将其发送给服务器。
* 服务器
  * 服务器收到客户端发送的加密后的Pre-Master Secret后，使用自己的私钥解密得到对称密钥。此时，客户端和服务器都有了相同的对称密钥（Master Secret）。客户端和服务器分别使用前面两次握手中协商的随机数和Master Secret计算出一个对话密钥（Session Key），用于后续通信的对称加密。握手结束后，双方发送Finished消息，通知对方握手过程已经完成，可以开始加密通信。

* 如何理解对称和非对称
  * 对一个数据的加密和解密是否使用同一个密钥


### MySQl主键索引和普通索引的区别

* 主键索引索引数据 然后普通索引索引着主键ID
* 主键索引要求值不能重复 并且不能为null
* 主键索引的数据结构是聚簇索引  普通索引的结构是非聚簇索引
* 聚簇索引的叶子节点得到的是行数据
* 非聚簇索引的叶子节点得到的是Id,需要回表得到对应的行
* 主键索引是唯一的，每个表只能有一个主键索引。普通索引可以是唯一的，也可以允许重复值。
* 主键索引可以由用户手动指定，也可以由MySQL自动创建。普通索引需要用户自己创建
* 主键索引在查询和检索时的性能通常较高，因为它是唯一的且通常是聚簇索引
* 普通索引的性能受到索引的数据结构、查询条件和配置的影响，在一些查询场景下，性能可能较低。

### JVM的内存管理

```java
1. Java内存分区：
在Java虚拟机中，内存被划分为不同的区域，主要包括：

程序计数器（Program Counter Register）：

记录当前线程执行的字节码行号，用于支持线程切换和恢复。
Java虚拟机栈（Java Virtual Machine Stacks）：

每个线程都有一个私有的虚拟机栈，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法的调用和返回都与虚拟机栈有关。
本地方法栈（Native Method Stack）：

与虚拟机栈类似，用于执行本地（native）方法。
Java堆（Java Heap）：

用于存放对象实例。在堆中，可以分为新生代（Young Generation）、老年代（Old Generation）和永久代/元空间（PermGen/Metaspace）等。
方法区（Method Area）：

用于存储类信息、常量、静态变量、即时编译后的代码等。
运行时常量池（Runtime Constant Pool）：

存储编译时生成的常量和符号引用。

```

```java
2. 垃圾回收（Garbage Collection）：
Java的垃圾回收机制负责自动管理内存，主要包括：

垃圾回收算法：

常见的垃圾回收算法有标记-清除、复制、标记-整理等。不同的算法适用于不同的场景。
垃圾收集器：

Java虚拟机提供了多种垃圾收集器，包括Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS（Concurrent Mark-Sweep）、G1（Garbage-First）等，每个收集器有不同的特点和适用场景。
垃圾回收的时机：

垃圾回收的时机由虚拟机自行判断。在新生代，主要使用Minor GC；在老年代，主要使用Major GC或Full GC。
垃圾回收的影响：

垃圾回收会影响程序的性能，因为在垃圾回收期间，应用程序的线程通常需要暂停。因此，需要根据具体应用场景选择合适的垃圾收集器。
3. 内存模型（Memory Model）：
Java内存模型定义了多线程程序中各个线程如何与主内存、工作内存进行交互，保证多线程间的可见性、有序性和一致性。主要涉及到：

主内存和工作内存：

主内存是线程共享的内存区域，工作内存是线程私有的内存区域。
内存屏障（Memory Barriers）：

内存屏障用于控制指令重排序，保证指令按照预期顺序执行。
happens-before关系：

happens-before关系是一种在多线程环境下保证操作顺序性的规则，确保正确的线程间通信。

```


### HTTPS


* https的核心： 加密 非对称加密  对称加密
* https如何保证安全：TLS四次握手 交换密钥 数据使用对称加密
* 密钥通过什么信息进行交换：TLS四次握手交换
* 证书如何保证安全： CA发布官方证书，使用公开的HASH算法得到hash1，客户端使用私钥加密Hash1,得到签名，组合起来是数字证书，发送给客户端


