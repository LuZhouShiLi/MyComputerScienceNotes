# 阿里淘天


## hashmap.put流程

* 在Java中，HashMap是一种基于哈希表的Map接口的非同步实现。当我们调用put方法时，主要是将键值对添加到HashMap中。如果键已经存在，则替换其值。下面是put方法的基本流程，假设我们使用的是Java 8及以上版本的HashMap实现：

* 计算键的哈希值：首先，计算键对象的hashCode()方法返回的哈希值。这个哈希值用于决定键值对在哈希表中的存储位置。

* 处理哈希冲突：由于哈希表的大小有限，不同的键可能会计算得到相同的哈希值，这称为哈希冲突。Java的HashMap通过链表和红黑树来处理冲突：

* 如果计算得到的位置上没有任何元素，直接将键值对存储在这个位置。
* 如果这个位置上有元素，但是键不同，那么会发生哈希冲突。Java 8之前，HashMap通过链表来解决冲突；Java 8及以后，当链表长度超过阈值（默认为8）时，链表转换为红黑树，以减少查找时间。
* 键值对的存储：如果插入的键已经存在，那么它的值将被新的值替换，并返回旧的值。如果是新键，则添加键值对，并返回null。

* 扩容：如果当前哈希表的大小达到了负载因子定义的容量（默认的负载因子是0.75），那么哈希表将进行扩容操作，通常是当前容量的两倍，然后重新计算每个键值对在新表中的位置。



## concurrenthashmap



* ConcurrentHashMap 是 Java 并发包中提供的一个线程安全的哈希表实现。相比于 Hashtable 和通过 Collections.synchronizedMap 包装的 HashMap（这两种方式都是对整个表加锁来实现线程安全），ConcurrentHashMap 采用了分段锁（Segmentation）的概念，极大地提高了并发访问的效率。下面是其主要特点和工作原理：

* 线程安全：可以被多个线程并发访问，且在内部处理了所有的同步细节，确保了线程安全
* 高并发性能：将数据分为多个段，每一个段独立枷锁，支持多线程并发读写操作，从而减少锁的竞争，提高了并发性能
* 键和值都不允许为 null：与 HashMap 不同，ConcurrentHashMap 不允许键（Key）或值（Value）为 null。


## 分段所

* 分段锁：内部结构被细分为一系列的小哈希表，每一个哈希表对应一个Segment,每一个Segment独自维护自己的锁
* Segmen数量：默认情况下，初始的数量是16 并且这个数量会直接影响并发级别
* 锁的粒度减小：只有当多线程访问的是同一个Segment时，才会存在锁竞争，因此相对于整个哈希表枷锁，大大减少锁竞争，提高并发效率


## cas


* 更细粒度的锁机制CAS synchronized
* 节点锁：每个节点在进行插入、更新、删除等操作时，通过 synchronized 锁定节点，而不是像以前那样锁定整个 Segment。
* CAS 操作：在某些操作中，为了减少锁的使用，采用了 CAS 操作来保证数据的一致性，例如在节点的插入过程中。
* 链表转红黑树：当链表中的元素数量过多时，链表会转换为红黑树，以减少搜索时间


## 知道java几面异常的(exception类)的体系结构嘛



### Java 的异常体系结构主要分为两大类：Throwable 类及其子类。在这两大类中，主要分为 Error 和 Exception。这个体系结构设计使得 Java 程序能够处理各种正常和非正常的情况。

### Throwable
所有错误和异常的最顶层父类是 Throwable，它有两个主要的子类：Error 和 Exception。Throwable 类中包含了异常处理所需的各种方法，如获取异常信息的 getMessage()、获取异常堆栈的 printStackTrace() 等。

### Error
**Error 类表示编译时和系统错误。**这类错误发生时，Java 运行时环境（JRE）通常无法恢复，因此大多数错误都与底层资源有关，如系统资源不足、虚拟机错误等。开发者在编写应用程序时，通常不会尝试去捕获这类错误。典型的 Error 有 OutOfMemoryError（内存不足）、StackOverflowError（栈溢出）等

### Exception
Exception 类是程序正常运行中可以捕获和处理的异常条件的父类，它主要分为两类：Checked Exceptions（受检异常）和 Unchecked Exceptions（非受检异常）。

### Checked Exceptions

* 这类异常在编译时必须被捕获或声明抛出，否则编译器将报错。它们通常是外部错误，表示程序在运行时可能遇到的预期错误。例如，IOException、SQLException 等。

### Unchecked Exceptions

* 这类异常包括 RuntimeException 及其子类，编译器不要求强制捕获或声明抛出。这些异常通常是程序错误，如试图在空对象上调用方法时抛出的 NullPointerException、数组越界异常 ArrayIndexOutOfBoundsException 等




### 异常处理原则
尽量具体地捕获异常。这意味着如果可能，应该捕获具体的异常类型，而不是简单地捕获 Exception 或 Throwable。
对于 Error 类的错误，一般不进行捕获，因为大多数情况下应用程序无法恢复这类错误。
对于受检异常，如果方法无法处理，则应该在方法签名中声明抛出，让调用者知道并处理这些异常。
避免滥用异常处理，尤其是对于 RuntimeException，应当通过改进程序逻辑来预防这类异常的发生


## 对象头都有什么内容

* 对象头主要分为两部分：Mark Word和Class Metadata Address

* **对象头是JVM管理对象所必需的结构，它包含了对象在运行时的各种状态信息。通过对象头，JVM能够了解对象的锁状态、类型信息、数组长度等，这对于JVM的内存管理、垃圾回收、同步锁等功能的实现至关重要**


### Mark Word


* Mark Word是对象头中的一个非常重要的部分，它存储了对象自身的运行时数据，比如哈希码（HashCode）、锁状态信息、线程持有的锁、偏向线程ID、偏向时间戳等。Mark Word的内容会随着对象状态的改变而改变。具体包含：

* 对象哈希码：系统默认生成的，用于确定对象在哈希表中的位置。
* 锁信息：包括锁的状态（如偏向锁、轻量级锁、重量级锁等）以及锁的归属线程。
* 垃圾回收分代年龄：对象在堆中存活的年龄。
* 偏向锁状态和偏向线程ID：JVM为了减少锁操作的开销，引入了偏向锁。当对象头的Mark Word记录了偏向锁状态和偏向的线程ID时，表示该对象偏向于某个特定的线程


###  Class Metadata Address（类型指针）

* Class Metadata Address是对象头的另一部分，它是一个指针，指向对象所属类的元数据，包含了类的信息，如类的名称、父类、方法、变量等信息。这部分信息用于确定对象的类型，以及在Java虚拟机（JVM）中如何处理这个对象。

* 数组长度：对于数组类型的对象，对象头中还会包含一个数组长度的字段，用以确定数组的大小


## CMS


* JVM中的一种垃圾回收算法GC
* 主要目标是获取最短回收停顿时间。它主要用于收集老年代的垃圾，适用于对响应时间有高要求的场景。
* CMS 是基于“标记-清除”算法实现的，但它尽可能地减少了应用程序暂停的时间，主要通过并发回收和分阶段回收来实现


### CMS工作过程


* 初始标记（Initial Mark）：这个阶段需要停止应用程序线程（Stop-The-World, STW），但只是标记从根节点直接可达的对象。由于直接关联的对象数量不多，这个阶段通常很快完成。

* 并发标记（Concurrent Mark）：从初始标记的对象出发，遍历整个对象图进行标记，这个过程不需要暂停应用线程，是并发执行的。

* 重新标记（Remark）：因为在并发标记期间应用程序线程还在运行，可能会有新的垃圾生成或者对象引用发生变化，所以需要重新标记确保标记的准确性。这个阶段会有短暂的 STW 停顿，通常通过算法如增量更新（Incremental Update）或原始快照（Snapshot-At-The-Beginning, SATB）来减少停顿时间。

* 并发清除（Concurrent Sweep）：清除阶段也是并发执行的，此时会清理掉标记过程中确定为已死亡的对象，释放内存空间。


* 特点
  * 并发收集：除了初始标记和重新标记阶段，其他工作都是并发进行的，大大减少了垃圾收集时的停顿时间。
  * 低停顿：CMS 设计的主要目标是避免长时间的垃圾收集停顿，特别适用于互联网站或者客户端交互较多的应用。
  * 碎片化问题：由于 CMS 基于“标记-清除”算法，不会像“复制”算法那样在整理内存布局，因此长时间运行后会产生较多内存碎片。为了解决这个问题，CMS 提供了一个可选的“并发压缩”阶段，但是在此阶段会引入短暂的停顿。

## 线程池，讲一讲，怎么用？什么时候创建线程？(具体说)


* 线程池（Thread Pool）是一种基于池化技术的线程管理机制，它允许创建一个线程池，预先创建一定数量的线程，放入空闲队列中。当有任务到来时，可以直接使用池中的线程，执行完毕后，线程不会销毁，而是再次返回线程池中等待下一次任务。这种方式可以减少在处理大量短生命周期的任务时频繁创建和销毁线程的性能开销，提高了响应速度，降低了资源消耗。

### 使用

* 在Java中，线程池的实现主要通过java.util.concurrent.Executor框架实现，其中Executors类提供了一些静态方法生成不同类型的线程池
* Executors.newCachedThreadPool(): 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
* Executors.newFixedThreadPool(int nThreads): 创建一个固定大小的线程池，每当提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
* Executors.newFixedThreadPool(int nThreads): 创建一个固定大小的线程池，每当提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
* 
### 创建线程时机

* 固定大小（FixedThreadPool）和可缓存（CachedThreadPool）线程池
  * 当任务提交给线程池时，如果线程池中的线程数没有达到核心线程数（FixedThreadPool的nThreads
  * CachedThreadPool没有核心线程概念），则创建线程执行这个任务
  * 对于CachedThreadPool，如果提交任务时线程池中有空闲线程，则复用空闲线程执行任务。如果没有空闲线程，创建新线程。线程空闲超过一定时间（默认60秒）后会被回收。




* 单线程化（SingleThreadExecutor）线程池：

任务总是由唯一的线程执行，如果该线程因异常终止，会创建一个新线程来继续执行后续的任务，保证顺序执行各个任务。

* 定时线程池（ScheduledThreadPoolExecutor）：

核心线程数固定，非核心线程数无限制，非核心线程空闲时立即被回收。核心线程会一直存活，即使处于空闲状态也不会被回收。


## 线程池的工作机制
* 任务提交：当提交一个任务时，线程池会首先判断核心线程池里的线程是否都在执行任务，如果不是，则创建一个新的工作线程来执行任务；如果核心线程都在执行任务，则将任务存放在队列中。
* 队列满载：如果队列已满，而且核心线程数已达到最大，则根据拒绝策略来处理无法执行的任务。
* 创建线程：如果工作队列已满，且当前运行的线程少于最大线程数，则创建新的线程来处理任务。
* 线程回收：如果一个线程空闲时间超过了指定的空闲时间，则线程将被终止和回收



## .我线程池放了几万个线程，有什么问题？


* 资源消耗：每个线程都会占用系统资源，特别是内存。Java虚拟机（JVM）中，每个线程的栈大小通常在256KB到1MB之间，几万个线程可能会导致巨大的内存占用，甚至造成内存溢出（OutOfMemoryError）
* 上下文切换：线程数量过多会导致频繁的上下文切换，因为CPU需要在多个线程间切换，每次切换都需要保存和加载寄存器、栈等信息，这会消耗大量的CPU时间，从而降低程序整体的执行效率。
* 系统稳定性：大量线程运行可能会导致操作系统稳定性降低，甚至系统崩溃。


## JMM


&emsp;Java内存模型（Java Memory Model，JMM）是一种抽象的概念，主要是围绕着并发编程在内存读写上的规范，旨在解决由多线程通过共享内存进行通信时可能遇到的问题。JMM定义了线程如何以及何时可以看到其他线程修改过后的共享变量的值，以及如何同步访问共享变量。

### 特性



* 原子性（Atomicity）：保证指令不会受到线程上下文切换的影响，执行的操作在一个线程中是不可中断的。
* 可见性（Visibility）：一个线程对共享变量的修改，可以被其他线程立即看到。Java提供了volatile、synchronized、final等关键字来保证操作的可见性。
* 有序性（Ordering）：保证程序执行的顺序按照代码的先后顺序执行。由于编译器优化（重排序），执行顺序可能会有所不同，但JMM通过happen-before原则来保证有序性。


### Happens-Before原则

* MM定义了“happens-before”原则，以确定程序中不同操作之间的关系。如果操作A happens-before操作B，那么对A的写入对B来说是可见的，并且A的执行顺序在B之前。happens-before原则是理解并发程序内存交互的关键。


### 保证并发安全


为了在并发程序中保证共享数据的正确性和一致性，JMM提供了一系列同步措施，包括：

* volatile关键字：保证了变量的可见性和部分有序性，但不保证原子性。
* synchronized关键字：可以保证块结构的原子性、可见性和有序性。
* final关键字：被final修饰的字段，构造函数外其他线程可见时，保证了初始化过程的完成。

## JVM内存模型

* JVM内存模型定义了不同的运行时数据区域，每个区域都有其特定的作用，包括堆（Heap）、方法区（Method Area）、Java栈（Java Stack）、本地方法栈（Native Method Stack）和程序计数器（Program Counter Register）

### 堆
* 堆是JVM内存模型中最大的一块，它被所有线程共享。
主要用于存储对象实例和数组。
堆内存分为年轻代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation，Java 8中已被元空间Metaspace替代）。

### 方法区

* 方法区也是被所有线程共享的内存区域。
* 用于存储已被虚拟机加载的类信息、常量、静态变量等数据。
在Java 8及以后的版本中，永久代（PermGen）被元空间（Metaspace）所替代

### Java栈

* Java栈是线程私有的，每个线程创建时都会创建自己的Java栈。
* 用于存储局部变量、操作数栈、方法调用的帧等。
* Java栈是工作在方法调用和方法执行过程中的，它通过帧（Frame）来实现这些过程

### 本地方法栈

* 本地方法栈与Java栈类似，但它是为虚拟机使用到的本地（Native）方法服务的。
* 和Java栈一样，本地方法栈也是线程私有的

### 程序计数器


* 程序计数器是当前线程所执行的字节码的行号指示器。
* 在任意时刻，一个CPU只会执行一个线程中的指令。因此，每个线程都需要一个独立的程序计数器，以便线程切换后能恢复到正确的执行位置


## 元空间满了，可能是什么原因？

* 类加载过多:如果应用程序加载了大量的类，这些类的元数据信息就会占用更多的元空间内存。这种情况常见于大型应用或使用了大量第三方库的应用中。
* 动态生成类：某些框架或工具（如动态代理、CGLIB、ASM等）会在运行时动态生成类。如果这些动态生成的类过多，并且长时间存活，会占用大量的元空间
* 类未被卸载
在某些情况下，如果类加载器的生命周期很长或者和应用程序的生命周期一样长，加载的类就不会被卸载，从而导致元空间内存不断增加。Web应用容器（如Tomcat）部署的应用如果不正确地管理类加载器，也可能导致这种问题。
4. 元空间大小设置不当
如果元空间的初始大小（-XX:MetaspaceSize）或最大值（-XX:MaxMetaspaceSize）设置得太小，可能会导致元空间不足。虽然元空间会根据需要自动扩展，但是如果达到了其最大限制，仍然会报OutOfMemoryError。

解决方法
针对元空间满的问题，可以尝试以下几种解决方法：

增加元空间的最大大小：通过调整-XX:MaxMetaspaceSize参数来增加元空间的最大允许大小。
优化类的使用：减少不必要的类加载，避免动态生成过多的类。
合理使用类加载器：在使用Web应用容器时，确保类加载器能够按预期工作，避免类加载泄露。
分析内存使用：使用JVM工具（如jconsole、VisualVM等）分析元空间的使用情况，确定是哪些类占用了较多的空间，进而找到根本原因。











