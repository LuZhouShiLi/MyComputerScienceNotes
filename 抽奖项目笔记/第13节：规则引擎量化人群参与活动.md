# 第13节：规则引擎量化人群参与活动



## 概述


* 使用组合模式搭建用于量化人群的规则引擎，用于用户参与活动之前，通过规则引擎过滤性别、年龄、首单消费、消费金额、忠实用户等各类身份来量化出具体可参与的抽奖活动。通过这样的方式控制运营成本和精细化运营

* 增加规则引擎开发需要的相关配置类表:rule_tree,rule_tree_node，rule_tree_node_line
* 运用组合模式搭建规则引擎领域服务，包括:logic逻辑过滤器，engine引擎执行器
* 修改lotter-infrastructure基础层中仓储实现类更为合适的注解未@Repository包括:ActivityRepository，RuleRepository,StrategyRepository,UserTakeActivityRepository




## 库表设计

* 组合模式的特点就像是搭建出一棵二叉树，而库表中则需要把这样一颗二叉树存放进去，那么这里就需要包括：树根、树茎、子叶、果实。在具体的逻辑实现中则需要通过子叶判断走哪个树茎以及最终筛选出一个果实来。


* rule_tree

```java
CREATE TABLE `rule_tree` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tree_name` varchar(64) DEFAULT NULL COMMENT '规则树NAME',
  `tree_desc` varchar(128) DEFAULT NULL COMMENT '规则树描述',
  `tree_root_node_id` bigint(20) DEFAULT NULL COMMENT '规则树根ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10002 DEFAULT CHARSET=utf8;


```



* rule_tree_node

```java
CREATE TABLE `rule_tree_node` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tree_id` int(2) DEFAULT NULL COMMENT '规则树ID',
  `node_type` int(2) DEFAULT NULL COMMENT '节点类型；1子叶、2果实',
  `node_value` varchar(32) DEFAULT NULL COMMENT '节点值[nodeType=2]；果实值',
  `rule_key` varchar(16) DEFAULT NULL COMMENT '规则Key',
  `rule_desc` varchar(32) DEFAULT NULL COMMENT '规则描述',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=123 DEFAULT CHARSET=utf8;


```



* rule_tree_node_line

```java
CREATE TABLE `rule_tree_node_line` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tree_id` bigint(20) DEFAULT NULL COMMENT '规则树ID',
  `node_id_from` bigint(20) DEFAULT NULL COMMENT '节点From',
  `node_id_to` bigint(20) DEFAULT NULL COMMENT '节点To',
  `rule_limit_type` int(2) DEFAULT NULL COMMENT '限定类型；1:=;2:>;3:<;4:>=;5<=;6:enum[枚举范围];7:果实',
  `rule_limit_value` varchar(32) DEFAULT NULL COMMENT '限定值',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;


```



## 应用场景

![图 0](../images/f8a72c755e44048412a56a6771a621aa90dbed2c7b746d7cc23a583fafacd4d9.png)  



* 基于量化决策引擎，筛选用户身份标签，找到符合参与的活动号，拿到活动号码之后，就可以参与到具体的抽奖活动中
* 通常量化决策引擎也是一种用于差异化人群的规则过滤器，不只是可以过滤出活动，也可以判断是否可以参与这个抽奖活动中
* 在我们的这个抽奖系统之后，后面会使用规则引擎领域服务，**在应用层座一层封装之后，由接口层进行调用使用，也就是用户参与活动之前，要做一层规则引擎过滤**



## 功能开发



### 工程结构


![图 2](../images/f323e71e28a8b03b664b97641e55b92385e88f05c46597065719fba9a27abb12.png)  


### model层


* 首先定义好几个VO对象

#### TreeRootVO

```java
package cn.itedus.lottery.domain.rule.model.vo;

/**
 * 规则树根的配置
 */
public class TreeRootVO {

    // 规则树ID
    private Long treeId;

    // 规则树根ID
    private Long treeRootNodeId;


    // 规则树名称
    private String treeName;


    public Long getTreeId() {
        return treeId;
    }

    public void setTreeId(Long treeId) {
        this.treeId = treeId;
    }

    public Long getTreeRootNodeId() {
        return treeRootNodeId;
    }

    public void setTreeRootNodeId(Long treeRootNodeId) {
        this.treeRootNodeId = treeRootNodeId;
    }

    public String getTreeName() {
        return treeName;
    }

    public void setTreeName(String treeName) {
        this.treeName = treeName;
    }

    @Override
    public String toString() {
        return "TreeRootVO{" +
                "treeId=" + treeId +
                ", treeRootNodeId=" + treeRootNodeId +
                ", treeName='" + treeName + '\'' +
                '}';
    }
}


```


#### TreeNodeVO


```java
package cn.itedus.lottery.domain.rule.model.vo;

import java.util.List;

/**
 * 规则树节点信息
 */
public class TreeNodeVO {

    // 规则树ID
    private  Long treeId;

    // 规则树节点ID
    private Long treeNodeId;

    // 节点类型
    private Integer nodeType;

    // 节点值
    private String nodeValue;


    private String ruleKey;// 规则Key

    // 规则描述
    private String ruleDesc;

    // 节点链路
    private List<TreeNodeLineVO> treeNodeLineVOList;


    public Long getTreeId() {
        return treeId;
    }

    public void setTreeId(Long treeId) {
        this.treeId = treeId;
    }

    public Long getTreeNodeId() {
        return treeNodeId;
    }

    public void setTreeNodeId(Long treeNodeId) {
        this.treeNodeId = treeNodeId;
    }

    public Integer getNodeType() {
        return nodeType;
    }

    public void setNodeType(Integer nodeType) {
        this.nodeType = nodeType;
    }

    public String getNodeValue() {
        return nodeValue;
    }

    public void setNodeValue(String nodeValue) {
        this.nodeValue = nodeValue;
    }

    public String getRuleKey() {
        return ruleKey;
    }

    public void setRuleKey(String ruleKey) {
        this.ruleKey = ruleKey;
    }

    public String getRuleDesc() {
        return ruleDesc;
    }

    public void setRuleDesc(String ruleDesc) {
        this.ruleDesc = ruleDesc;
    }

    public List<TreeNodeLineVO> getTreeNodeLineVOList() {
        return treeNodeLineVOList;
    }

    public void setTreeNodeLineVOList(List<TreeNodeLineVO> treeNodeLineVOList) {
        this.treeNodeLineVOList = treeNodeLineVOList;
    }

    @Override
    public String toString() {
        return "TreeNodeVO{" +
                "treeId=" + treeId +
                ", treeNodeId=" + treeNodeId +
                ", nodeType=" + nodeType +
                ", nodeValue='" + nodeValue + '\'' +
                ", ruleKey='" + ruleKey + '\'' +
                ", ruleDesc='" + ruleDesc + '\'' +
                ", treeNodeLineVOList=" + treeNodeLineVOList +
                '}';
    }
}


```

#### TreeNodeLineVO


```java

package cn.itedus.lottery.domain.rule.model.vo;

/**
 * 规则树线信息
 */
public class TreeNodeLineVO {

    // 节点from  父节点
    private Long nodeIdFrom;

    private Long nodeIdTo;// 子节点

    private Integer ruleLimitType;// 限定类型

    private String ruleLimitValue;// 限定值

    public Long getNodeIdFrom() {
        return nodeIdFrom;
    }

    public void setNodeIdFrom(Long nodeIdFrom) {
        this.nodeIdFrom = nodeIdFrom;
    }

    public Long getNodeIdTo() {
        return nodeIdTo;
    }

    public void setNodeIdTo(Long nodeIdTo) {
        this.nodeIdTo = nodeIdTo;
    }

    public Integer getRuleLimitType() {
        return ruleLimitType;
    }

    public void setRuleLimitType(Integer ruleLimitType) {
        this.ruleLimitType = ruleLimitType;
    }

    public String getRuleLimitValue() {
        return ruleLimitValue;
    }

    public void setRuleLimitValue(String ruleLimitValue) {
        this.ruleLimitValue = ruleLimitValue;
    }

    @Override
    public String toString() {
        return "TreeNodeLineVO{" +
                "nodeIdFrom=" + nodeIdFrom +
                ", nodeIdTo=" + nodeIdTo +
                ", ruleLimitType=" + ruleLimitType +
                ", ruleLimitValue='" + ruleLimitValue + '\'' +
                '}';
    }
}

```



### Req请求


```java

package cn.itedus.lottery.domain.rule.model.req;

import java.util.Map;


/**
 * 决策请求
 */
public class DecisionMatterReq {
    //  规则树ID
    private Long treeId;

    // 用户ID
    private String userId;

    //决策值
    private Map<String,Object> valMap;

    public Long getTreeId() {
        return treeId;
    }

    public void setTreeId(Long treeId) {
        this.treeId = treeId;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public Map<String, Object> getValMap() {
        return valMap;
    }

    public void setValMap(Map<String, Object> valMap) {
        this.valMap = valMap;
    }
}

```


### TreeRuleRich 定义多叉树


```java
package cn.itedus.lottery.domain.rule.model.aggregates;


import cn.itedus.lottery.domain.rule.model.vo.TreeNodeVO;
import cn.itedus.lottery.domain.rule.model.vo.TreeRootVO;

import java.util.Map;

/**
 * 规则树聚合信息  描述一颗多叉树  =  根节点  + 子节点
 */
public class TreeRuleRich {
    // 树根信息
    private TreeRootVO treeRoot;

    // 树节点ID -> 子节点  多个子节点
    private Map<Long, TreeNodeVO> treeNodeMap;


    public TreeRootVO getTreeRoot() {
        return treeRoot;
    }

    public void setTreeRoot(TreeRootVO treeRoot) {
        this.treeRoot = treeRoot;
    }

    public Map<Long, TreeNodeVO> getTreeNodeMap() {
        return treeNodeMap;
    }

    public void setTreeNodeMap(Map<Long, TreeNodeVO> treeNodeMap) {
        this.treeNodeMap = treeNodeMap;
    }
}


```



#### EngineResult


```java

package cn.itedus.lottery.domain.rule.model.res;


/**
 * 决策结果
 */
public class EngineResult {

    // 执行结果
    private boolean isSuccess;

    // 用户ID
    private String userId;

    // 规则树ID
    private Long treeId;

    // 果实节点ID
    private Long nodeId;

    // 果实节点值
    private String nodeValue;

    public EngineResult() {
    }

    public EngineResult(String userId, Long treeId, Long nodeId, String nodeValue) {
        this.isSuccess = true;
        this.userId = userId;
        this.treeId = treeId;
        this.nodeId = nodeId;
        this.nodeValue = nodeValue;
    }

    public boolean isSuccess() {
        return isSuccess;
    }

    public void setSuccess(boolean success) {
        isSuccess = success;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public Long getTreeId() {
        return treeId;
    }

    public void setTreeId(Long treeId) {
        this.treeId = treeId;
    }

    public Long getNodeId() {
        return nodeId;
    }

    public void setNodeId(Long nodeId) {
        this.nodeId = nodeId;
    }

    public String getNodeValue() {
        return nodeValue;
    }

    public void setNodeValue(String nodeValue) {
        this.nodeValue = nodeValue;
    }
}


```

### Repository

**该接口用于查询树的详细节点信息，接口实现类在infrastructure层**

```java
package cn.itedus.lottery.domain.rule.repository;


import cn.itedus.lottery.domain.rule.model.aggregates.TreeRuleRich;

/**
 * 规则信息仓储服务接口
 */
public interface IRuleRepository {

    /**
     * 查询规则决策树配置
     * @param treeId  决策树ID
     * @return
     */
    TreeRuleRich queryTreeRuleRich(Long treeId);

}


```


![图 5](../images/0b894b39c93f61eebe39f612e8f95a6513025c7c8f5a19f71edbd96c667584ba.png)  

**infra层主要就是定义具体的数据仓储服务DAO，DAO提供各种PO对象信息的查询，然后repository提供各种dao的数据查询操作，都是Domain领域下面的接口实现类**





