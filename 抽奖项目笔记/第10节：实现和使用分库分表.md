# 第10节：实现和使用分库分表

## 分库分表

* 因为业务量大，数据增长快，需要把数据拆分到不同的库表中去，减轻数据库压力
* 主要有垂直拆分和水平拆分
* 垂直拆分：按照业务将表进行分类，分布到不同的数据库中，这样数据的压力分担到不同的库中，最终一个数据库由很多表构成，每一个表对应着不同的业务，也就是专库专用
* 水平拆分：如果垂直拆分遭到问题，可以使用水平拆分，相对于垂直拆分得区别是：垂直拆分是把不同的表拆分到不同得数据库中，但是水平拆分是把同一个表拆分到不同的数据库中

## 路由设计


* 关于AOP切片拦截得使用，这是因为需要给使用数据库路由的方法坐上标记，便于处理分库分表逻辑
* 数据源得切换操作，既然有分库那么就会设计在多个数据源之间进行连接切换，以便于把数据分配给不同得数据库
* 数据库表寻址操作，一条数据分配到哪个数据库，哪张表，都需要进行索引计算，在方法调用的过程中最终通过ThreadLocal记录
* 为了能让数据均匀的分配到不同的库表中，还需要考虑如何进行数据散列操作，不能分库分表之后，让数据都集中在某个库的某个表

要用到的技术：
  * aop
  * 数据源切换
  * 散列算法
  * 哈希寻址
  * ThreadLocal
  * SpringBoot的starter



## 技术调研

* HashMap和ThreadLocal都用到了哈希索引、散列算法以及在数据膨胀的时候拉链寻址和开放寻址


### ThreadLocal

* 斐波那契的哈希值计算方式：i * 0x61c88647 + 0x61c88647;
* 然后将哈希值使用&操作符和十六进制数15进行位与运算
* 寻址方式：数据碰撞的时候进行开放寻址，从碰撞节点之后进行存放元素

```java
@Test
public void test_idx() {
    int hashCode = 0;
    for (int i = 0; i < 16; i++) {
        hashCode = i * 0x61c88647 + 0x61c88647;
        int idx = hashCode & 15;
        System.out.println("斐波那契散列：" + idx + " 普通散列：" + (String.valueOf(i).hashCode() & 15));
    }
} 


```


### HashMap


![图 0](../images/8341339b6c8bab44d78695cf750cf6f8f96f87f62da0526226a4ab267d5c2a28.png)  


* 数据结构：哈希数组+ 链表 + 红黑树
* 散列算法：扰动函数、哈希索引，可以让数据更加散列的分布
* 寻址方式：通过拉链寻址的方式解决数据碰撞，数据存放会进行索引地址，遇到碰撞产生数据链表，链表长度超过8进行扩容或者进行树化


```java
public static int disturbHashIdx(String key, int size) {
    return (size - 1) & (key.hashCode() ^ (key.hashCode() >>> 16));
}
```

