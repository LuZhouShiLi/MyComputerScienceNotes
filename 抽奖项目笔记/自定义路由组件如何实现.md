# 自定义路由组件如何实现

## DBRouter


* @Documented：指示将此注解包含在javadoc中。
* @Retention(RetentionPolicy.RUNTIME)：指示注解在运行时保留，这样就可以通过反射机制读取注解的信息。
* @Target({ElementType.TYPE, ElementType.METHOD})：指示该注解可以用在类、接口（包括注解类型）或枚举声明，以及方法上。

* 注解中定义了一个名为 key 的元素，默认值为空字符串。这个 key 元素用于指定进行分库分表时用于路由计算的字段名称。在实际应用中，可以在类或方法上使用 @DBRouter 注解，并提供一个字段名作为 key 的值，这样框架就知道基于该字段的值来计算路由到哪个数据库或哪个表
* 如果有一个订单服务，订单数据需要根据订单ID进行分表，那么可以在处理订单的服务方法上加上 @DBRouter(key="orderId") 注解，这样调用该方法时，框架就会根据订单ID的值来决定数据应该路由到哪个具体的表中


```java
package cn.bugstack.middleware.db.router.annotation;

import java.lang.annotation.*;


/**
 * @description: 路由注解
 * @author: 小傅哥，微信：fustack
 * @date: 2021/9/22
 * @github: https://github.com/fuzhengwei
 * @Copyright: 公众号：bugstack虫洞栈 | 博客：https://bugstack.cn - 沉淀、分享、成长，让自己和他人都能有所收获！
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface DBRouter {

    /** 分库分表字段 */
    String key() default "";

}


```


## DBRouterStrategy


* @Documented：表明这个注解应该被 javadoc 工具记录。默认情况下，javadoc 是不包括注解的。使用 @Documented 注解修饰后，在生成文档时，注解将被包括在内。
* @Retention(RetentionPolicy.RUNTIME)：指明该注解的保留策略是在运行时有效。这意味着，通过反射可以在运行时获取到这个注解的信息。
* @Target({ElementType.TYPE, ElementType.METHOD})：指明该注解可以被用于类、接口（包括注解类型）或枚举的声明，以及方法上
* 注解中定义了一个名为 splitTable 的元素，它的类型是布尔类型，默认值为 false。这个元素用于指示是否启用分表策略。如果设置为 true，则表示启用分表，框架或应用应根据具体的路由逻辑将数据存储到不同的表中
* 可以在类或方法上加上 @DBRouterStrategy(splitTable = true) 注解，来标明这个类或方法操作的数据需要进行分表处理。这为处理大规模数据提供了方便，使得数据库操作可以更加灵活地适应不同的数据规模和性能要求，特别是在高并发和大数据量的场景下


```java
package cn.bugstack.middleware.db.router.annotation;

import java.lang.annotation.*;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface DBRouterStrategy {

    boolean splitTable() default false;

}


```


## DBRouterConfig

```java
package cn.bugstack.middleware.db.router;

/**
 * @description: 数据路由配置
 * @author: 小傅哥，微信：fustack
 * @date: 2021/9/22
 * @github: https://github.com/fuzhengwei
 * @Copyright: 公众号：bugstack虫洞栈 | 博客：https://bugstack.cn - 沉淀、分享、成长，让自己和他人都能有所收获！
 */
public class DBRouterConfig {

    /**
     * 分库数量
     */
    private int dbCount;

    /**
     * 分表数量
     */
    private int tbCount;

    /**
     * 路由字段
     */
    private String routerKey;

    public DBRouterConfig() {
    }

    public DBRouterConfig(int dbCount, int tbCount, String routerKey) {
        this.dbCount = dbCount;
        this.tbCount = tbCount;
        this.routerKey = routerKey;
    }

    public int getDbCount() {
        return dbCount;
    }

    public void setDbCount(int dbCount) {
        this.dbCount = dbCount;
    }

    public int getTbCount() {
        return tbCount;
    }

    public void setTbCount(int tbCount) {
        this.tbCount = tbCount;
    }

    public String getRouterKey() {
        return routerKey;
    }

    public void setRouterKey(String routerKey) {
        this.routerKey = routerKey;
    }
}


```


## DBRouterBase

* 这个 DBRouterBase 类提供了数据库路由的基础配置，主要是用来获取当前线程所指定的表索引（tbIdx），它通过调用 DBContextHolder.getTBKey() 方法来实现。这是一个典型的使用线程局部变量（ThreadLocal）来存储每个线程独有的数据库表索引的做法
* DBContextHolder 类很可能是一个使用 ThreadLocal 来保存数据库操作相关上下文信息的工具类，包括但不限于当前请求指定的数据库实例和数据表。这种做法使得应用可以在处理请求时，动态地选择合适的数据库和表进行操作，而不会相互干扰，实现了线程安全
* 总的来说，DBRouterBase 类及其配套的上下文持有者 DBContextHolder，是实现动态数据源路由（如分库分表场景）的一个基本模式。它们使得应用能够根据请求的不同，灵活地切换目标数据库和表，有助于提升应用处理大规模数据的能力和性能

```java
package cn.bugstack.middleware.db.router;

public class DBRouterBase {

    private String tbIdx;

    public String getTbIdx() {
        return DBContextHolder.getTBKey();
    }

}


```


## DBContextHolder

* DBContextHolder 类是一个核心组件，负责在当前线程上下文中保存和管理数据库（DB）和表（TB）的键值。这些键值用于动态数据源路由的实现，特别是在分库分表的场景中，确保每个数据库操作都能定位到正确的数据库实例和数据表。
* 通过 ThreadLocal 类的使用，DBContextHolder 能够为每个线程独立存储其数据库键（dbKey）和表键（tbKey）。这种做法保证了在多线程环境下的线程安全，因为每个线程只能访问自己的数据库键和表键，不会受到其他线程的干扰
* setDBKey(String dbKeyIdx) 和 setTBKey(String tbKeyIdx)：设置当前线程的数据库键和表键。
* getDBKey() 和 getTBKey()：获取当前线程的数据库键和表键。
* clearDBKey() 和 clearTBKey()：清除当前线程的数据库键和表键，通常在请求处理结束后调用，以避免内存泄漏。

```java
package cn.bugstack.middleware.db.router;

public class DBContextHolder {

    private static final ThreadLocal<String> dbKey = new ThreadLocal<String>();
    private static final ThreadLocal<String> tbKey = new ThreadLocal<String>();

    public static void setDBKey(String dbKeyIdx){
        dbKey.set(dbKeyIdx);
    }

    public static String getDBKey(){
        return dbKey.get();
    }

    public static void setTBKey(String tbKeyIdx){
        tbKey.set(tbKeyIdx);
    }

    public static String getTBKey(){
        return tbKey.get();
    }

    public static void clearDBKey(){
        dbKey.remove();
    }

    public static void clearTBKey(){
        tbKey.remove();
    }

}


```

## DBRouterJointPoint

&emsp;整个 DBRouterJoinPoint 类的设计思路是通过 AOP 技术实现数据库的动态路由，它能够根据业务需求动态选择合适的数据库或表，从而实现高效的数据存取策略


* @Aspect: 表明这是一个切面类，用于定义通知（advice）和切点（pointcuts）。
* DBRouterJoinPoint构造函数: 接收 DBRouterConfig 和 IDBRouterStrategy 的实例。这两个参数分别代表数据库路由的配置信息（如分库分表数量、路由键等）和路由策略。
* @Pointcut: 定义了一个切点，匹配所有被 @DBRouter 注解标记的方法。这意味着任何使用了 @DBRouter 注解的方法都会被这个切面拦截。
* @Around: 定义了一个环绕通知，它将围绕 @DBRouter 注解的方法执行。这个通知首先解析注解中指定的路由键或使用全局路由键，然后从方法参数中提取路由键的值，接着根据这个值调用路由策略进行路由，最后执行目标方法。
* doRouter方法: 这是环绕通知的实现逻辑。它首先检查路由键是否有效，然后从方法参数中提取路由键的值，使用路由策略根据这个值进行路由。方法执行完毕后，清理路由上下文。
* getMethod和getAttrValue方法: getMethod 方法用于获取当前拦截的方法的反射对象。getAttrValue 方法用于从方法参数中提取出路由键指定的属性值。如果路由键对应的是一个字符串参数，直接返回该字符串；否则，尝试反射获取对象属性值。
* getValueByName和getFieldByName方法: 这两个方法通过反射机制从给定的对象中获取指定名称的属性值和属性对象（Field），以支持动态获取路由键的值

## DBRouterStrategy

&emsp;IDBRouterStrategy接口定义了数据库路由策略的契约，这对于使用多个数据库或表来有效分配数据的应用程序至关重要。这种策略对于通过根据某些标准将数据分布在各种数据库或表中来水平扩展应用程序特别有用，通常称为分片

## DBRouterStrategyHashCode


&emsp;DBRouterStrategyHashCode 类实现了 IDBRouterStrategy 接口，采用哈希路由策略来分配数据库和表的索引。这种策略可以有效地将数据分散到多个数据库和表中，以实现负载均衡和提高数据查询、插入的性能。

* doRouter(String dbKeyAttr)：

* 基于输入的路由键（dbKeyAttr），通过哈希算法计算得出数据应该路由到的数据库和表的索引。计算过程中使用了扰动函数来增加哈希散列的随机性和均匀性，这个概念源自 JDK 的 HashMap 实现。
* 计算得到的库表索引被设置到 DBContextHolder 中，这是一个使用 ThreadLocal 存储当前线程所选择的数据库和表的索引的容器。使用 ThreadLocal 可以确保在同一线程中，数据库路由的选择在多个数据库操作间保持一致。
setDBKey(int dbIdx) 和 setTBKey(int tbIdx)：

* 这两个方法允许手动设置当前线程选择的数据库和表的索引。这在需要覆盖自动路由逻辑的场景中非常有用。
dbCount() 和 tbCount()：

* 返回配置中定义的数据库数量和每个数据库中的表数量。
clear()：

* 清理当前线程存储的数据库和表的索引。在操作完成后调用此方法是很重要的，以避免 ThreadLocal 导致的潜在内存泄露





```java
package cn.bugstack.middleware.db.router;

import cn.bugstack.middleware.db.router.annotation.DBRouter;
import cn.bugstack.middleware.db.router.strategy.IDBRouterStrategy;
import org.apache.commons.lang.StringUtils;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * @description: 数据路由切面，通过自定义注解的方式，拦截被切面的方法，进行数据库路由
 * @author: 小傅哥，微信：fustack
 * @date: 2021/9/22
 * @github: https://github.com/fuzhengwei
 * @Copyright: 公众号：bugstack虫洞栈 | 博客：https://bugstack.cn - 沉淀、分享、成长，让自己和他人都能有所收获！
 */
@Aspect
public class DBRouterJoinPoint {

    private Logger logger = LoggerFactory.getLogger(DBRouterJoinPoint.class);

    private DBRouterConfig dbRouterConfig;

    private IDBRouterStrategy dbRouterStrategy;

    public DBRouterJoinPoint(DBRouterConfig dbRouterConfig, IDBRouterStrategy dbRouterStrategy) {
        this.dbRouterConfig = dbRouterConfig;
        this.dbRouterStrategy = dbRouterStrategy;
    }

    @Pointcut("@annotation(cn.bugstack.middleware.db.router.annotation.DBRouter)")
    public void aopPoint() {
    }

    /**
     * 所有需要分库分表的操作，都需要使用自定义注解进行拦截，拦截后读取方法中的入参字段，根据字段进行路由操作。
     * 1. dbRouter.key() 确定根据哪个字段进行路由
     * 2. getAttrValue 根据数据库路由字段，从入参中读取出对应的值。比如路由 key 是 uId，那么就从入参对象 Obj 中获取到 uId 的值。
     * 3. dbRouterStrategy.doRouter(dbKeyAttr) 路由策略根据具体的路由值进行处理
     * 4. 路由处理完成比，就是放行。 jp.proceed();
     * 5. 最后 dbRouterStrategy 需要执行 clear 因为这里用到了 ThreadLocal 需要手动清空。关于 ThreadLocal 内存泄漏介绍 https://t.zsxq.com/027QF2fae
     */
    @Around("aopPoint() && @annotation(dbRouter)")
    public Object doRouter(ProceedingJoinPoint jp, DBRouter dbRouter) throws Throwable {
        String dbKey = dbRouter.key();
        if (StringUtils.isBlank(dbKey) && StringUtils.isBlank(dbRouterConfig.getRouterKey())) {
            throw new RuntimeException("annotation DBRouter key is null！");
        }
        dbKey = StringUtils.isNotBlank(dbKey) ? dbKey : dbRouterConfig.getRouterKey();
        // 路由属性
        String dbKeyAttr = getAttrValue(dbKey, jp.getArgs());
        // 路由策略
        dbRouterStrategy.doRouter(dbKeyAttr);
        // 返回结果
        try {
            return jp.proceed();
        } finally {
           dbRouterStrategy.clear();
        }
    }

    private Method getMethod(JoinPoint jp) throws NoSuchMethodException {
        Signature sig = jp.getSignature();
        MethodSignature methodSignature = (MethodSignature) sig;
        return jp.getTarget().getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());
    }

    public String getAttrValue(String attr, Object[] args) {
        if (1 == args.length) {
            Object arg = args[0];
            if (arg instanceof String) {
                return arg.toString();
            }
        }

        String filedValue = null;
        for (Object arg : args) {
            try {
                if (StringUtils.isNotBlank(filedValue)) {
                    break;
                }
                // filedValue = BeanUtils.getProperty(arg, attr);
                // fix: 使用lombok时，uId这种字段的get方法与idea生成的get方法不同，会导致获取不到属性值，改成反射获取解决
                filedValue = String.valueOf(this.getValueByName(arg, attr));
            } catch (Exception e) {
                logger.error("获取路由属性值失败 attr：{}", attr, e);
            }
        }
        return filedValue;
    }

    /**
     * 获取对象的特定属性值
     * 
     * @author tang
     * @param item 对象
     * @param name 属性名
     * @return 属性值
     */
    private Object getValueByName(Object item, String name) {
        try {
            Field field = getFieldByName(item, name);
            if (field == null) {
                return null;
            }
            field.setAccessible(true);
            Object o = field.get(item);
            field.setAccessible(false);
            return o;
        } catch (IllegalAccessException e) {
            return null;
        }
    }

    /**
     * 根据名称获取方法，该方法同时兼顾继承类获取父类的属性
     * 
     * @author tang
     * @param item 对象
     * @param name 属性名
     * @return 该属性对应方法
     */
    private Field getFieldByName(Object item, String name) {
        try {
            Field field;
            try {
                field = item.getClass().getDeclaredField(name);
            } catch (NoSuchFieldException e) {
                field = item.getClass().getSuperclass().getDeclaredField(name);
            }
            return field;
        } catch (NoSuchFieldException e) {
            return null;
        }
    }

}


```



## 数据源配置

* 这个 DBRouterConfig 类定义了数据库路由的配置信息，包括分库数量（dbCount）、分表数量（tbCount）以及路由字段（routerKey）。这些配置项是实现分库分表路由逻辑的基础，可以根据实际应用的需求进行设置
* 分库数量（dbCount）：指的是数据库被分割成多少个子库，这对于读写分离、负载均衡等场景非常有用
* 分表数量（tbCount）：表示每个数据库中表被分割成多少个子表，这有助于数据的水平切分，提高查询效率和数据管理的灵活性。
* 路由字段（routerKey）：是决定数据存储位置的关键字段，通常根据这个字段的值来计算数据应该存储在哪个子库和子表中
* 这个配置类可以在应用启动时被初始化，并在整个应用中被访问和使用，以保证数据正确地分布在各个子库和子表中。它是实现数据库分库分表中间件功能的核心部分之一，使得应用能够灵活地处理大规模数据，同时保持高性能和可扩展性


```java
package cn.bugstack.middleware.db.router.config;

import cn.bugstack.middleware.db.router.DBRouterConfig;
import cn.bugstack.middleware.db.router.DBRouterJoinPoint;
import cn.bugstack.middleware.db.router.dynamic.DynamicDataSource;
import cn.bugstack.middleware.db.router.dynamic.DynamicMybatisPlugin;
import cn.bugstack.middleware.db.router.strategy.IDBRouterStrategy;
import cn.bugstack.middleware.db.router.strategy.impl.DBRouterStrategyHashCode;
import cn.bugstack.middleware.db.router.util.PropertyUtil;
import cn.bugstack.middleware.db.router.util.StringUtils;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.SystemMetaObject;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.context.EnvironmentAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;

import javax.sql.DataSource;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

@Configuration
public class DataSourceAutoConfig implements EnvironmentAware {

    /**
     * 分库全局属性
     */
    private static final String TAG_GLOBAL = "global";

    /**
     * 连接池属性
     */
    private static final String TAG_POOL = "pool";


    /**
     * 数据源配置组
     */
    private Map<String, Map<String, Object>> dataSourceMap = new HashMap<>();

    /**
     * 默认数据源配置
     */
    private Map<String, Object> defaultDataSourceConfig;

    /**
     * 分库数量
     */
    private int dbCount;

    /**
     * 分表数量
     */
    private int tbCount;

    /**
     * 路由字段
     */
    private String routerKey;

    @Bean(name = "db-router-point")
    @ConditionalOnMissingBean
    public DBRouterJoinPoint point(DBRouterConfig dbRouterConfig, IDBRouterStrategy dbRouterStrategy) {
        return new DBRouterJoinPoint(dbRouterConfig, dbRouterStrategy);
    }

    @Bean
    public DBRouterConfig dbRouterConfig() {
        return new DBRouterConfig(dbCount, tbCount, routerKey);
    }

    @Bean
    public Interceptor plugin() {
        return new DynamicMybatisPlugin();
    }

    // 可参考 README 配置连接池；https://gitcode.net/KnowledgePlanet/db-router-spring-boot-starter/-/blob/master/README.md
    private DataSource createDataSource(Map<String, Object> attributes) {
        try {
            DataSourceProperties dataSourceProperties = new DataSourceProperties();
            dataSourceProperties.setUrl(attributes.get("url").toString());
            dataSourceProperties.setUsername(attributes.get("username").toString());
            dataSourceProperties.setPassword(attributes.get("password").toString());

            String driverClassName = attributes.get("driver-class-name") == null ? "com.zaxxer.hikari.HikariDataSource" : attributes.get("driver-class-name").toString();
            dataSourceProperties.setDriverClassName(driverClassName);

            String typeClassName = attributes.get("type-class-name") == null ? "com.zaxxer.hikari.HikariDataSource" : attributes.get("type-class-name").toString();
            DataSource ds = dataSourceProperties.initializeDataSourceBuilder().type((Class<DataSource>) Class.forName(typeClassName)).build();

            MetaObject dsMeta = SystemMetaObject.forObject(ds);
            Map<String, Object> poolProps = (Map<String, Object>) (attributes.containsKey(TAG_POOL) ? attributes.get(TAG_POOL) : Collections.EMPTY_MAP);
            for (Map.Entry<String, Object> entry : poolProps.entrySet()) {
                // 中划线转驼峰
                String key = StringUtils.middleScoreToCamelCase(entry.getKey());
                if (dsMeta.hasSetter(key)) {
                    dsMeta.setValue(key, entry.getValue());
                }
            }
            return ds;
        } catch (ClassNotFoundException e) {
            throw new IllegalArgumentException("can not find datasource type class by class name", e);
        }
    }

    @Bean
    public DataSource createDataSource() {
        // 创建数据源
        Map<Object, Object> targetDataSources = new HashMap<>();
        for (String dbInfo : dataSourceMap.keySet()) {
            Map<String, Object> objMap = dataSourceMap.get(dbInfo);
            // 根据objMap创建DataSourceProperties,遍历objMap根据属性反射创建DataSourceProperties
            DataSource ds = createDataSource(objMap);
            targetDataSources.put(dbInfo, ds);

        }

        // 设置数据源
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        dynamicDataSource.setTargetDataSources(targetDataSources);
        // db0为默认数据源
        dynamicDataSource.setDefaultTargetDataSource(createDataSource(defaultDataSourceConfig));

        return dynamicDataSource;
    }

    @Bean
    public IDBRouterStrategy dbRouterStrategy(DBRouterConfig dbRouterConfig) {
        return new DBRouterStrategyHashCode(dbRouterConfig);
    }

    @Bean
    public TransactionTemplate transactionTemplate(DataSource dataSource) {
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);

        TransactionTemplate transactionTemplate = new TransactionTemplate();
        transactionTemplate.setTransactionManager(dataSourceTransactionManager);
        transactionTemplate.setPropagationBehaviorName("PROPAGATION_REQUIRED");
        return transactionTemplate;
    }

    @Override
    public void setEnvironment(Environment environment) {
        String prefix = "mini-db-router.jdbc.datasource.";

        dbCount = Integer.parseInt(Objects.requireNonNull(environment.getProperty(prefix + "dbCount")));
        tbCount = Integer.parseInt(Objects.requireNonNull(environment.getProperty(prefix + "tbCount")));
        routerKey = environment.getProperty(prefix + "routerKey");
        // 分库分表数据源
        String dataSources = environment.getProperty(prefix + "list");
        Map<String, Object> globalInfo = getGlobalProps(environment, prefix + TAG_GLOBAL);
        for (String dbInfo : dataSources.split(",")) {
            final String dbPrefix = prefix + dbInfo;
            Map<String, Object> dataSourceProps = PropertyUtil.handle(environment, dbPrefix, Map.class);
            injectGlobal(dataSourceProps, globalInfo);
            dataSourceMap.put(dbInfo, dataSourceProps);
        }

        // 默认数据源
        String defaultData = environment.getProperty(prefix + "default");
        defaultDataSourceConfig = PropertyUtil.handle(environment, prefix + defaultData, Map.class);
        injectGlobal(defaultDataSourceConfig, globalInfo);
    }

    private Map<String, Object> getGlobalProps(Environment environment, String key) {
        try {
            return PropertyUtil.handle(environment, key, Map.class);
        } catch (Exception e) {
            return Collections.EMPTY_MAP;
        }
    }

    private void injectGlobal(Map<String, Object> origin, Map<String, Object> global) {
        for (String key : global.keySet()) {
            if (!origin.containsKey(key)) {
                origin.put(key, global.get(key));
            } else if (origin.get(key) instanceof Map) {
                injectGlobal((Map<String, Object>) origin.get(key), (Map<String, Object>) global.get(key));
            }
        }
    }

}


```



