# 第09节：ID生成策略领域开发

## 概述

* 使用雪花算法、阿帕奇工具包RandomStringUtils、日期拼接、三种方式生成ID、分别用在订单号、策略ID、活动号生成上


* 使用策略模式把三种生成ID的算法进行统一包装，由调用方决定使用哪种生成ID的策略。策略模式属于行为模式的一种，一个类的行为或算法可以在运行时进行更改
* 雪花算法本章节使用的是工具包 hutool 包装好的工具类，一般在实际使用雪花算法时需要做一些优化处理，比如支持时间回拨、支持手工插入、简短生成长度、提升生成速度等。
* 而日期拼接和随机数工具包生成方式，都需要自己保证唯一性，一般使用此方式生成的ID，都用在单表中，本身可以在数据库配置唯一ID。那为什么不用自增ID，因为自增ID通常容易被外界知晓你的运营数据，以及后续需要做数据迁移到分库分表中都会有些麻烦


## 支撑领域

* 订单号：唯一、大量、订单创建时使用、分库分表
* 活动号：唯一、少量、活动创建时使用、单库单表
* 策略号：唯一、少量、活动创建时使用、单库单表

## 策略模式

* 外部的调用方会根据不同的场景选择适合的ID生成策略，而策略模式就非常适合这一个场景的使用

## 工程结构


* IIdGenerator，定义生成ID的策略接口 RandomNumeric ShortCode SnowFlake 是三种生成ID的策略
* IdContext ID生成上下文，也就是从这里提供策略配置服务


## IIdGenerator

```java
package cn.itedus.lottery.domain.support.ids;

/**
 * 生成ID接口
 */
public interface IIdGenerator {

    /**
     * 获取ID 随机算法  雪花算法  日期算法
     * @return
     */
    long nextId();
}


```

## 随机算法


```java
package cn.itedus.lottery.domain.support.ids.policy;

import cn.itedus.lottery.domain.support.ids.IIdGenerator;
import org.apache.commons.lang3.RandomStringUtils;
import org.springframework.stereotype.Component;

/**
 * 随机生成ID算法
 */

@Component
public class RandomNumeric implements IIdGenerator {

    @Override
    public long nextId() {
        return Long.parseLong(RandomStringUtils.randomNumeric(11));
    }
}


```

## 短码生成算法

* 初始化Calendar对象，获取当前日期和时间，并且提取年份 年的周数 星期几和小时
* 代码通过连接从当前日期和时间派生的组件，包括年份与2024的偏移、小时、格式化的周、天以及一个三位数的随机数，构建了一个唯一标识符。
* 生成的标识符被转换为长整型并由"nextId"方法返回


```java
package cn.itedus.lottery.domain.support.ids.policy;

import cn.itedus.lottery.domain.support.ids.IIdGenerator;
import org.springframework.stereotype.Component;

import javax.sound.midi.MidiSystem;
import java.util.Calendar;
import java.util.Random;

/**
 * 短码生成策略 仅仅支持很小的调用量  用于生成活动配置类编号 保证全局唯一
 */
@Component
public class ShortCode implements IIdGenerator {
    @Override
    public long nextId() {
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        int week = calendar.get(Calendar.WEEK_OF_YEAR);
        int day= calendar.get(Calendar.DAY_OF_WEEK);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);

        // 打乱排序
        StringBuilder idStr = new StringBuilder();
        idStr.append(year - 2024);
        idStr.append(hour);
        idStr.append(String.format("%02d",week));
        idStr.append(day);
        idStr.append(String.format("%03d",new Random().nextInt(1000)));
        return Long.parseLong(idStr.toString());
    }
}


```


## 雪花算法

```java
package cn.itedus.lottery.domain.support.ids.policy;

import cn.hutool.core.lang.Snowflake;
import cn.hutool.core.net.NetUtil;
import cn.hutool.core.util.IdUtil;
import cn.itedus.lottery.domain.support.ids.IIdGenerator;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

/**
 * 雪花算法
 * 使用hutool 工具类提供的雪花算法  提供生成的ID服务
 */
@Component
public class SnowFlake implements IIdGenerator {

    private Snowflake snowflake;

    @PostConstruct
    public  void init(){
        long workerId;

        try{
            workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr());
        }catch(Exception e){
            workerId = NetUtil.getLocalhostStr().hashCode();
        }

        workerId = workerId >> 16 & 31;
        long dataCenterId = 1L;
        snowflake = IdUtil.createSnowflake(workerId,dataCenterId);
    }

    @Override
    public synchronized long nextId() {
        return snowflake.nextId();
    }
}


```
