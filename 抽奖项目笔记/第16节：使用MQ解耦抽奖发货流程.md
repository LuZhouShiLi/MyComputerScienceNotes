# 第16节：使用MQ解耦抽奖发货流程


## 使用MQ消息的特性，将用户抽奖到发货流程进行解耦，这个过程包括消息发送，库表中状态的更新，消息的接受消费，发将状态的处理等

## 开发日志

* 在数据库表user_strategy_export 添加字段mq_state 这个字段用于发送MQ成功更新库表状态，如果MQ消息发送失败则需要通过定时补偿MQ消息
* 启动KAFKA新增topic:lottery_invoice用于发货单消息，当抽奖完成之后则发送一个发货单，在异步处理发货流程，这个部分就是MQ的解耦流程使用
* 在ActivityProcessImpl # doDrawProcess活动抽奖流程编排中补全用户抽奖之后，发送MQ触达异步奖品发送的流程


## 创建主题（Topic）

* 启动zookeeper

* 启动kafka
```java
.\bin\windows\kafka-server-start.bat .\config\server.properties

```


* 创建一个MQ的主题

```java

 .\bin\windows\kafka-topics.bat --create --bootstrap-server localhost:9092--replication-factor 1 --partitions 1 MQ
```


## 流程

![图 0](../images/c533a13a3fded3165211b6c19fe3b0fd16f941a6c5737766239116cc343d2591.png)  

* 从用户发起抽奖到中奖之后开始 就是MQ处理发奖的流程
* 因为MQ消息的发送是不具备事务性的，也就是你在发送MQ可能会失败，哪怕成功率是很大，也有一定概率失败，所以在MQ发送完成之后需要知道是否发送成功，进行库表状态更新，如果发送失败则需使用worker来步长MQ发送
* 最后MQ发送完成到消费，也是可能有失败的，比如处理失败，更新库表失败，但是不无论是什么失败都需要保证MQ进行重试处理，而保证MQ消息重试的前提就是服务的幂等性，否则你在重试的过程中就造成了流程异常，比如更新次数多了 数据库插入多了 给用户发奖多了等


## MQ服务


&emsp;关于MQ的使用 无论是Kafka还是RocketMQ 基本方式都是类似的 一个生产消息 一个监听消息 

### 生产者


* Component注解表示这个类是一个spring组件，spring会自动检测并且管理
* 定义logger实例用于记录日志
* KafkaTemplate注入 使用Resouce注解自动注入KafkaTemplate<String,Object>实例，KafakaTemplate是Spring人提供的一个用于发送消息到Kafka的高级抽象类。泛型<String,Object> 指示键类型是String 值类型是Obejct
* 定义MQ主题
* 发送给消息kafkaTemplate.send 发送消息到kafka 返回一个异步处理结果

```java
@Component
public class KafkaProducer {

    private Logger logger = LoggerFactory.getLogger(KafkaProducer.class);

    @Resource
    private KafkaTemplate<String, Object> kafkaTemplate;

    /**
     * MQ主题：中奖发货单
     */
    public static final String TOPIC_INVOICE = "lottery_invoice";

    /**
     * 发送中奖物品发货单消息
     *
     * @param invoice 发货单
     */
    public ListenableFuture<SendResult<String, Object>> sendLotteryInvoice(InvoiceVO invoice) {
        String objJson = JSON.toJSONString(invoice);
        logger.info("发送MQ消息 topic：{} bizId：{} message：{}", TOPIC_INVOICE, invoice.getuId(), objJson);
        return kafkaTemplate.send(TOPIC_INVOICE, objJson);
    }

}


```

* 将所有的生产消息都放到KafkaProducer中 并对外提供一个可以发送MQ消息的方法
* 因为我们配置的类型转换为StringDeserializer 所以发送消息的方式是JSON字符串  当然 这个编解码器可以重写 满足其他类型数据

## 消费者

* Kafka的消息监听器
* onMessahe方法是消息消费的具体实现，接受三个参数
* 将消息内容转换为InvoiceVO对象 这是通过Json.parseObject实现的
* 通过distributionGoodsFactory.getDistributionGoodsService(invoiceVO.getAwardType());根据奖品类型获取相应的发奖服务，然后通过doDistribution方法进行奖品发放
* 使用Assert.isTrue校验发奖结果 确保发奖成功  否则抛出异常
* acknowledge手动确认消息

```java
package cn.itedus.lottery.application.mq.consumer;

import cn.hutool.core.lang.Assert;
import cn.itedus.lottery.common.Constants;
import cn.itedus.lottery.domain.activity.model.vo.InvoiceVO;
import cn.itedus.lottery.domain.award.model.req.GoodsReq;
import cn.itedus.lottery.domain.award.model.res.DistributionRes;
import cn.itedus.lottery.domain.award.service.factory.DistributionGoodsFactory;
import cn.itedus.lottery.domain.award.service.goods.IDistributionGoods;
import com.alibaba.fastjson.JSON;
import jdk.internal.org.jline.terminal.spi.JansiSupport;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.Optional;

/**
 * 中奖发货单监听消息
 */
@Component
public class LotteryInvoiceListener {

    private Logger logger = LoggerFactory.getLogger(LotteryInvoiceListener.class);

    @Resource
    private DistributionGoodsFactory distributionGoodsFactory;

    @KafkaListener(topics = "lottery_invoice",groupId = "lottery")
    public void onMessage(ConsumerRecord<?,?> record, Acknowledgment ack, @Header(KafkaHeaders.RECEIVED_TOPIC) String topic){
        Optional<?> message = Optional.ofNullable(record.value());

        // 判断消息是否存在
        if(!message.isPresent()){
            return;
        }

        // 处理MQ消息
        try{
            // 转化对象  将接收的json字符串转换为目标对象
            InvoiceVO invoiceVO = JSON.parseObject((String) message.get(),InvoiceVO.class);

            // 获取发送奖品呢工厂 执行发奖
            IDistributionGoods distributionGoodsService = distributionGoodsFactory.getDistributionGoodsService(invoiceVO.getAwardType());
            DistributionRes distributionRes = distributionGoodsService.doDistribution(new GoodsReq(invoiceVO.getuId(), invoiceVO.getOrderId(), invoiceVO.getAwardId(), invoiceVO.getAwardName(), invoiceVO.getAwardContent()));

            Assert.isTrue(Constants.AwardState.SUCCESS.getCode().equals(distributionRes.getCode()),distributionRes.getInfo());

            // 3. 打印日志
            logger.info("消费MQ消息，完成 topic：{} bizId：{} 发奖结果：{}", topic, invoiceVO.getuId(), JSON.toJSONString(distributionRes));

            // 4. 消息消费完成
            ack.acknowledge();

        }  catch (Exception e) {
        // 发奖环节失败，消息重试。所有到环节，发货、更新库，都需要保证幂等。
        logger.error("消费MQ消息，失败 topic：{} message：{}", topic, message.get());
        throw e;
    }
    }

}


```
* 每一个MQ消息的消费都会有一个对应的xxxListener来处理消息体，如果您使用一些其他的Mq可能会看到一些抽象类来处理MQ消息集合
* 在这个LotteryInvoiceListener消息监听类中 **主要就是通过消息中的发奖类型获取到对应的奖品发货工厂，处理奖品的发奖操作**



## 抽奖流程解耦




