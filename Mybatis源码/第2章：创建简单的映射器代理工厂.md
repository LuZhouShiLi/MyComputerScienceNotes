# 第2章：创建简单的映射器代理工厂

## 概述

* 用 ORM 框架后，只需要通过简单配置即可对定义的 DAO 接口进行数据库的操作了

* 当我们设计一个ORM框架的过程中，首先考了把用户定义的数据库接口 xml配置的SQL语句 数据库三者联系起来 最适合的操作就是使用代理的方式进行处理，因为代理可以封装一个复杂的流程未接口对象的实现类

## 实现

* 首先提供一个映射器的代理实现类MapperProxy 通过代理类包装对数据库的操作
* 之后对MapperProxy代理类 提供工厂实例化操作 MapperProxyFactory#newInstance,为每一个DAO接口生成代理类
* 简单工厂模式

## MapperProxy


```java
package cn.bugstack.mybatis.binding;

import java.io.Serializable;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.util.Map;

/**
 * 映射器代理类
 */
public class MapperProxy<T> implements InvocationHandler, Serializable {

    private static final long serialVersionUID = -6424540398559729838L;// 版本控制 序列化对象需要


    private Map<String,String> sqlSession; // 一个映射  用于存储SQL语句或者数据库操作与对应的处理逻辑

    private final Class<T> mapperInterface;// 存储该代理实例所代表的接口的class对象

    public MapperProxy(Map<String, String> sqlSession, Class<T> mapperInterface) {
        this.sqlSession = sqlSession;
        this.mapperInterface = mapperInterface;
    }

    /**
     * 拦截对代理对象方法的调用
     * @param proxy the proxy instance that the method was invoked on
     *
     * @param method the {@code Method} instance corresponding to
     * the interface method invoked on the proxy instance.  The declaring
     * class of the {@code Method} object will be the interface that
     * the method was declared in, which may be a superinterface of the
     * proxy interface that the proxy class inherits the method through.
     *
     * @param args an array of objects containing the values of the
     * arguments passed in the method invocation on the proxy instance,
     * or {@code null} if interface method takes no arguments.
     * Arguments of primitive types are wrapped in instances of the
     * appropriate primitive wrapper class, such as
     * {@code java.lang.Integer} or {@code java.lang.Boolean}.
     *
     * @return
     * @throws Throwable
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        if(Object.class.equals(method.getDeclaringClass())){
            return method.invoke(this,args);
        }else{
            return "你被代理 "+ sqlSession.get(mapperInterface.getName() + "." + method.getName());
        }
    }
}


```

* MapperProxy 负责实现InvocationHandler接口的invoke方法 最终所有的实际调用都会调用到这个方法包装的逻辑
* MapperProxyFactory 是对MapperProxy的包装对外提供实例化对象的操作，后面对每一个操作数据库接口映射器注册代理的时候，需要使用到这各工厂类

* 通过实现invoke代理类接口 封装操作逻辑的方式 对外接口提供数据库操作对象
* sqlSession 在反射调用中获取对印度个操作直接执行并且返回结果即可
*  Object 提供的 toString、hashCode 等方法是不需要代理执行的，添加 Object.class.equals(method.getDeclaringClass()) 判断
*  



## MapperProxyFactory

```java
package cn.bugstack.mybatis.binding;


//import org.apache.ibatis.binding.MapperProxy;

import java.lang.reflect.Proxy;
import java.util.Map;

/**
 * 生成代理对象  映射器代理工厂 工厂模式 动态创建实现指定接口的代理实例
 * @param <T>
 */
public class MapperProxyFactory<T> {

    // 存储一个类的class对象 表示代理工厂为哪一个接口创建代理实例
    private final Class<T> mapperInterface;// 存储一个类的class对象 表示代理工厂将为哪一个接口创建代理实例

    // 指定代理工厂将为哪一个接口创建代理实例
    public MapperProxyFactory(Class<T> mapperInterface) {
        this.mapperInterface = mapperInterface;
    }

    /**
     * 调用处理器 处理对代理对象的所有方法调用 第一个参数存储sql和处理逻辑
     * @param sqlSession
     * @return
     */
    public T newInstance(Map<String,String> sqlSession){
        // 创建一个实例 用于处理对代理对象的所有被方法调用 构造函数接受一个参数 sql Session是一个映射  用于存储SQL语句和对应的处理逻辑
        final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession,mapperInterface);

        // 创建代理实例 第一个类加载器 定义代理类 第二个参数 表示代理类实现哪一个接口  第三个参数 实现接口实例 用于处理对代理实例的调用
        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(),new Class[]{mapperInterface},mapperProxy);
    }

}


```

* 将代理的创建封装起来 如果不做封装 那么每一个创建代理类的操作 都需要自己使用newProxyInstance进行处理 
* 再把复制信息传递给代理对象实例化操作，这样可以在我们调用具体的dao方法从sqlSession中取值



## 单元测试

* 在单测中创建 MapperProxyFactory 工厂，并手动给 sqlSession Map 赋值，这里的赋值相当于模拟数据库中的操作。
* 接下来再把赋值信息传递给代理对象实例化操作，这样就可以在我们调用具体的 DAO 方法时从 sqlSession 中取值了。

```java

package cn.bugstack.mybatis.test;

import cn.bugstack.mybatis.binding.MapperProxy;
import cn.bugstack.mybatis.binding.MapperProxyFactory;
import cn.bugstack.mybatis.test.dao.IActivityDao;
import cn.bugstack.mybatis.test.dao.IUserDao;
import cn.bugstack.mybatis.test.po.Activity;
import cn.bugstack.mybatis.test.po.User;
import com.alibaba.fastjson.JSON;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.Reader;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


public class ApiTest {

    private Logger logger = LoggerFactory.getLogger(ApiTest.class);

    /**
     * 测试两种使用动态代理的方式 工厂类和处理器类实现复杂的逻辑
     */
    @Test
    public void test_MapperProxyFactory(){

        // 工厂实例  只当IUSerDao解耦 用于生成该接口的代理实例
        MapperProxyFactory<IUserDao> factory = new MapperProxyFactory<>(IUserDao.class);

        // 存储方法命和对应的  模拟数据库操作或者查询结果
        Map<String,String> sqlSession = new HashMap<>();
        sqlSession.put("cn.bugstack.mybatis.test.dao.IUserDao.queryUserName", "模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户姓名");
        sqlSession.put("cn.bugstack.mybatis.test.dao.IUserDao.queryUserAge", "模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户年龄");

        // 调用newInstance方法  传入上面的sqlSession Map 创建一个实现类IUSERDao 接口的代理实例

        IUserDao userDao = factory.newInstance(sqlSession);

        String res = userDao.queryUserName("10001");
        logger.info("测试结果:{}",res);
    }

    /**
     * 直接使用Proxy.newProxyInstance方法 创建代理实例 适用于简单的代理场景
     */
    @Test
    public void test_proxy_class(){

        // 直接使用Proxy类的方法创建一个IUserDao的代理实例 拦截所有方法
        IUserDao userDao =(IUserDao) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
                new Class[]{IUserDao.class},(proxy,method,args)->"你被代理");

        String result = userDao.queryUserName("10001");
        System.out.println("测试结果:"+ result);
    }

}

```
