# Java代理模式


## 静态代理

&emsp;Java代理模式是一种设计模式，它为其他对象提供一个代理来控制对这个对象的访问，代理模式在Java开发中广泛使用，尤其是远程方法调用RMI，事务管理，延迟初始化等场景，代理模式主要分为静态代理和动态代理两种形式

* 静态代理在编译时就已经确定了代理类和目标对象的关系。
* 使用静态代理，需要为每一个被代理的类手动创建一个代理类，代理类需要实现与目标对象相同的接口，并在内部维护一个目标对象的引用，通过代理类对目标对象方法进行增强，首先额外的功能
* 步骤：
  * 定义接口：确定目标对象和代理对象共同遵循的接口
  * 实现接口：目标对象实现接口的方法
  * 创建代理类：代理类同样实现该接口，并在内部维护一个对象实际目标对象的引用，通过构造方法传入目标对象，代理类在实现接口方法的时候，可以在调用目标对象的方法前后添加额外的处理逻辑

## 动态代理

* 与静态代理，动态代理在运行的时候动态生成代理类和对象
* Java提供了两种动态代理：基于接口的动态代理和基于类的动态代理
* 基于接口的动态代理：
  * 创建一个实现了InvocationHandler接口的处理器类：该处理器类关联了真实对象，实现了invoke方法，invoke方法中封装了对真实对象方法的调用
  * 通过Proxy.newProxyInstance方法动态创建代理对象：这个方法需要加载真实对象的类加载器、真实对象实现的接口及上一步创建的处理器对象，返回一个实现了指定接口的代理实例
* 基于类的动态代理：
  * CGLIB（Code Generation Library）是一个第三方代码生成库，通过继承的方式实现动态代理，因此不需要接口。它在运行时动态生成被代理对象的子类，并在子类中重写父类方法，通过方法拦截技术插入增强代码


## 静态代理的步骤

* 定义一个接口：确定代理和真实对象的共同行为
* 实现该接口创建真实对象：具体实现接口的功能
* 创建一个代理类也实现这个接口：用来包装真实对象，同时在调用真实对象的方法前后，可以添加自己的操作
* 在代理类中维护一个真实对象的引用，通过构造方法传入真实对象
* 调用接口的方法，实际上执行的是代理类的方法

## 动态代理的步骤

* 定义一个或者多个接口以及实现类
* 创建一个实现InvocationHandler接口的类，他必须实现invoke方法
* 通过调用Proxy.newProxyInstance 方法 创建动态代理对象：
  * 类加载器（可以从已经加载的对象中获取）
  * 代理需要实现的接口列表（至少需要实现一个接口）
  * InvocationHandler 实例




